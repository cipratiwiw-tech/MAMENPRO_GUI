==========================================================================================
MAMENPRO ENGINE BUNDLE
ROOT PATH : C:\Users\rtauf\Desktop\BotBuatanMamen\MAMENPRO_GUI
CREATED   : 2026-01-06 06:34:54.018672
MODE      : WHITELIST + BLACKLIST
CONTENT   : ENGINE ONLY
==========================================================================================


==========================================================================================
FILE: engine\background_layer_pyav.py
==========================================================================================
import av
import numpy as np


class BackgroundLayer:
    def __init__(self):
        self.enabled = True
        self.path = None
        self.container = None
        self.stream = None

        self.x = 0
        self.y = 0
        self.scale = 100
        self.blur = 0   # placeholder (opsional)
        self.vig = 0    # placeholder (opsional)

        self._frame_cache = {}

    # =====================
    # SOURCE
    # =====================
    def set_source(self, path: str):
        self.path = path
        self._close()

        self.container = av.open(path)
        self.stream = self.container.streams.video[0]
        self.stream.thread_type = "AUTO"

        self._frame_cache.clear()

    def set_enabled(self, value: bool):
        self.enabled = value

    def update_state(self, data: dict):
        self.x = data.get("x", self.x)
        self.y = data.get("y", self.y)
        self.scale = data.get("scale", self.scale)
        self.blur = data.get("blur", self.blur)
        self.vig = data.get("vig", self.vig)

    # =====================
    # RENDER
    # =====================
    def render(self, canvas: np.ndarray, frame_idx: int, fps: float):
        if not self.enabled or not self.container:
            return canvas

        frame = self._get_frame(frame_idx)
        if frame is None:
            return canvas

        frame = self._apply_scale(frame)
        canvas = self._composite(canvas, frame)

        return canvas

    # =====================
    # INTERNAL
    # =====================
    def _get_frame(self, frame_idx: int):
        if frame_idx in self._frame_cache:
            return self._frame_cache[frame_idx].copy()

        try:
            self.container.seek(int(frame_idx / self.stream.average_rate))
        except Exception:
            pass

        for frame in self.container.decode(self.stream):
            img = frame.to_ndarray(format="rgb24")
            self._frame_cache[frame_idx] = img
            return img

        return None

    def _apply_scale(self, img: np.ndarray):
        if self.scale == 100:
            return img

        h, w = img.shape[:2]
        s = self.scale / 100.0
        nw = int(w * s)
        nh = int(h * s)

        return np.array(
            av.VideoFrame.from_ndarray(img, format="rgb24")
            .reformat(width=nw, height=nh)
            .to_ndarray()
        )

    def _composite(self, canvas, frame):
        ch, cw = canvas.shape[:2]
        fh, fw = frame.shape[:2]

        x = int(self.x)
        y = int(self.y)

        x1 = max(0, x)
        y1 = max(0, y)
        x2 = min(cw, x + fw)
        y2 = min(ch, y + fh)

        if x1 >= x2 or y1 >= y2:
            return canvas

        fx1 = x1 - x
        fy1 = y1 - y
        fx2 = fx1 + (x2 - x1)
        fy2 = fy1 + (y2 - y1)

        canvas[y1:y2, x1:x2] = frame[fy1:fy2, fx1:fx2]
        return canvas

    def _close(self):
        if self.container:
            self.container.close()
        self.container = None
        self.stream = None


==========================================================================================
FILE: engine\dummy_engine.py
==========================================================================================
# engine/dummy_engine.py
import numpy as np

class DummyEngine:
    """
    Mesin palsu untuk pengembangan UI.
    Tidak memproses video, hanya mencetak log ke terminal.
    """
    def __init__(self):
        print("[ENGINE] Dummy Engine Started (UI Mode)")
        self.clips = []

    def sync_clips(self, clips):
        self.clips = clips
        print(f"[ENGINE] Syncing {len(clips)} clips from GUI...")
        for i, clip in enumerate(clips):
            print(f"  > Clip {i}: {clip.name} (File: {clip.file_path})")

    def get_frame_at(self, t):
        # Kembalikan frame hitam kosong (1920x1080) agar PreviewPanel tidak error
        # Format: (Height, Width, Channel)
        return np.zeros((1080, 1920, 3), dtype=np.uint8)

==========================================================================================
FILE: engine\ffmpeg_renderer.py
==========================================================================================
def run_ffmpeg_thread(self):
        """Thread Render STABIL: Menghindari pipe blocking dan menampilkan log error"""
        import traceback
        output_filename = "MAMENPRO_RENDER_FINAL.mp4"
        
        try:
            # 1. Pastikan Dimensi Genap (Wajib untuk H.264)
            w = int(self.canvas.canvas_rect.width())
            h = int(self.canvas.canvas_rect.height())
            if w % 2 != 0: w += 1
            if h % 2 != 0: h += 1

            fps = 30
            duration = self.timeline.duration
            total_frames = int(duration * fps)
            
            print(f"üöÄ Render Start: {w}x{h} @ {fps}fps | {total_frames} frames")
            
            if total_frames <= 0:
                print("‚ùå Error: Total frames 0. Periksa timeline!")
                return

            # 2. Setup Command FFmpeg
            # PENTING: stderr=None agar log FFmpeg langsung keluar ke terminal Anda (CMD/VSCode)
            command = [
                'ffmpeg', '-y',
                '-f', 'rawvideo', '-vcodec', 'rawvideo',
                '-s', f'{w}x{h}',
                '-pix_fmt', 'bgra', 
                '-r', str(fps),
                '-i', '-', 
                '-c:v', 'libx264',
                '-pix_fmt', 'yuv420p',
                '-preset', 'ultrafast',
                '-crf', '23',
                output_filename
            ]

            # 3. Jalankan FFmpeg
            # Gunakan stderr=None atau sys.stderr agar tidak terjadi DEADLOCK
            process = subprocess.Popen(
                command, 
                stdin=subprocess.PIPE, 
                stderr=None,  # JANGAN GUNAKAN subprocess.PIPE jika tidak dibaca
                bufsize=10**8,
                creationflags=0x08000000 if os.name == 'nt' else 0
            )

            # 4. Loop Frame
            for i in range(total_frames):
                if self.is_rendering_stopped:
                    print("üõë Render stopped by user.")
                    break

                t = i / fps
                frame = self.timeline.get_frame(t)

                # ‚úÖ BACKGROUND ENGINE (JIKA ADA)
                if hasattr(self, "bg_layer") and self.bg_layer:
                    frame = self.bg_layer.render(frame, i, fps)

                
                # Jika engine gagal ambil frame, buat frame hitam
                if frame is None:
                    frame = np.zeros((h, w, 4), dtype=np.uint8)
                
                # Pastikan format BGRA (4 channel) sesuai input -pix_fmt bgra
                if frame.shape[2] == 3:
                    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2BGRA)
                
                # Resize paksa jika ada selisih resolusi
                if frame.shape[1] != w or frame.shape[0] != h:
                    frame = cv2.resize(frame, (w, h))

                # Tulis ke pipa
                try:
                    process.stdin.write(frame.tobytes())
                except BrokenPipeError:
                    print("üî• FFmpeg berhenti mendadak (Broken Pipe). Periksa log di atas!")
                    break

                if i % 15 == 0:
                    percent = int((i / total_frames) * 100)
                    QMetaObject.invokeMethod(self, "set_render_status", Qt.QueuedConnection, 
                                            Q_ARG(bool, True), Q_ARG(int, percent), Q_ARG(str, f"Frame {i}"))

            # 5. Tutup Pipa
            process.stdin.close()
            process.wait()
            print(f"‚úÖ Render Selesai: {output_filename}")

        except Exception as e:
            print("üî• CRITICAL RENDER ERROR:")
            traceback.print_exc() # Menampilkan baris error secara detail
        finally:
            QMetaObject.invokeMethod(self, "set_render_status", Qt.QueuedConnection, 
                                     Q_ARG(bool, False), Q_ARG(int, 100), Q_ARG(str, "Done"))

==========================================================================================
FILE: engine\frame_cache.py
==========================================================================================

from collections import OrderedDict


class FrameCache:
    """
    Cache frame berbasis waktu (detik)
    LRU + windowed
    """
    def __init__(self, max_frames=120):
        self.max_frames = max_frames
        self.cache = OrderedDict()

    def get(self, t):
        key = round(t, 3)
        if key in self.cache:
            self.cache.move_to_end(key)
            return self.cache[key]
        return None

    def put(self, t, frame):
        key = round(t, 3)
        self.cache[key] = frame
        self.cache.move_to_end(key)

        if len(self.cache) > self.max_frames:
            self.cache.popitem(last=False)

    def clear(self):
        self.cache.clear()


==========================================================================================
FILE: engine\interactive_text.py
==========================================================================================
from engine.interaction.interactive import InteractiveLayerMixin
from effects.text.text_advanced import TextAdvancedEffect

class InteractiveTextLayer(InteractiveLayerMixin, TextAdvancedEffect):
    """
    Wrapper GUI untuk TextAdvancedEffect
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


==========================================================================================
FILE: engine\preview_engine.py
==========================================================================================
# engine/preview/preview_engine.py
from PySide6.QtCore import QObject, QTimer, Signal
from engine.background_layer_pyav import BackgroundLayer



class PreviewEngine(QObject):
    sig_time_changed = Signal(float)  # Mengirimkan waktu dalam detik (float)
    sig_state_changed = Signal(bool) # True = Playing, False = Paused

    def __init__(self, fps=30):
        super().__init__()
        self.fps = fps
        self.current_time = 0.0
        self.duration = 0.0
        
        self.bg_layer = BackgroundLayer()
        self.timer = QTimer()
        self.timer.timeout.connect(self._on_tick)
        self.timer.setInterval(1000 / self.fps) # Misal 33ms untuk 30fps
        


    def _on_tick(self):
        self.current_time += 1.0 / self.fps
        if self.current_time >= self.duration:
            self.current_time = 0.0 # Loop atau stop
            
        self.sig_time_changed.emit(self.current_time)

    def set_time(self, seconds):
        """Update waktu secara manual (saat scrubbing slider)"""
        self.current_time = max(0.0, min(seconds, self.duration))
        self.sig_time_changed.emit(self.current_time)

    def toggle_play(self):
        if self.timer.isActive():
            self.timer.stop()
            self.sig_state_changed.emit(False)
        else:
            if self.duration > 0:
                self.timer.start()
                self.sig_state_changed.emit(True)

    def set_duration(self, seconds):
        self.duration = seconds

==========================================================================================
FILE: engine\pyav_engine.py
==========================================================================================

import av
from engine.frame_cache import FrameCache


class PyAVClip:
    def __init__(self, path, fps=30):
        self.container = av.open(path)
        
        # PERBAIKAN: Cek apakah ada stream video
        if len(self.container.streams.video) == 0:
            raise ValueError(f"File tidak memiliki stream video: {path}")
        
        self.stream = self.container.streams.video[0]
        self.stream.thread_type = "AUTO"
        self.time_base = float(self.stream.time_base)

        self.fps = fps
        self.cache = FrameCache(max_frames=180)

    def _decode_frame(self, t):
        pts = int(t / self.time_base)
        self.container.seek(
            pts,
            stream=self.stream,
            any_frame=False,
            backward=True
        )

        for frame in self.container.decode(self.stream):
            ft = frame.pts * self.time_base
            if ft >= t:
                return frame.to_ndarray(format="rgb24")
        return None

    def get_frame_at(self, t):
        cached = self.cache.get(t)
        if cached is not None:
            return cached

        frame = self._decode_frame(t)
        if frame is not None:
            self.cache.put(t, frame)

        return frame

    def prefetch(self, start_t, duration=1.0):
        """
        Prefetch frame ke depan (1 detik default)
        """
        step = 1.0 / self.fps
        t = start_t

        for _ in range(int(duration * self.fps)):
            if self.cache.get(t) is None:
                frame = self._decode_frame(t)
                if frame is not None:
                    self.cache.put(t, frame)
            t += step


==========================================================================================
FILE: engine\render_engine.py
==========================================================================================
import subprocess
import os
from PySide6.QtCore import QThread, Signal

class RenderWorker(QThread):
    sig_progress = Signal(str)
    sig_finished = Signal(bool, str)

    def __init__(self, items_data, output_path, duration, width=1080, height=1920):
        super().__init__()
        self.items = items_data
        self.output_path = output_path
        self.duration = duration
        self.canvas_w = width
        self.canvas_h = height

    def run(self):
        self.sig_progress.emit("üöÄ Memulai Render Engine...")

        # 1. SETUP INPUTS
        inputs = []
        filter_parts = [] # Kita gunakan list parts lalu di-join dengan ";"
        
        # Base Canvas (Hitam)
        # Kita beri label awal [base]
        filter_parts.append(f"color=c=black:s={self.canvas_w}x{self.canvas_h}:d={self.duration}[base]")
        
        last_out_label = "[base]"
        
        # Sort items berdasarkan Z-Value (Layer bawah render duluan)
        sorted_items = sorted(self.items, key=lambda x: x['z_value'])

        for idx, item in enumerate(sorted_items):
            file_path = item['path']
            
            # Input FFmpeg
            inputs.extend(['-i', file_path])
            
            # --- FILTER CHAIN PER ITEM ---
            
            scale_w = item['w']
            scale_h = item['h']
            start_t = item.get('start_time', 0)
            end_t = item.get('end_time', self.duration)
            x_pos = item['x']
            y_pos = item['y']
            
            # Label node
            # PENTING: Gunakan {idx} bukan i manual
            input_node = f"[{idx}:v]" 
            scaled_label = f"[scaled{idx}]"
            next_label = f"[layer{idx}]"

            # 1. Filter Scale
            # Mengubah ukuran input video sesuai canvas
            cmd_scale = f"{input_node}scale={scale_w}:{scale_h}{scaled_label}"
            filter_parts.append(cmd_scale)
            
            # 2. Filter Overlay
            # Menumpuk hasil scale ke atas layer sebelumnya (last_out_label)
            cmd_overlay = (
                f"{last_out_label}{scaled_label}overlay={x_pos}:{y_pos}:"
                f"enable='between(t,{start_t},{end_t})'{next_label}"
            )
            filter_parts.append(cmd_overlay)
            
            # Update label untuk iterasi berikutnya
            last_out_label = next_label

        # Gabungkan semua filter dengan pemisah TITIK KOMA (;)
        full_filter = ";".join(filter_parts)
        
        # 3. KONSTRUKSI COMMAND FFMPEG
        cmd = ['ffmpeg', '-y']
        cmd.extend(inputs)
        cmd.extend(['-filter_complex', full_filter])
        cmd.extend(['-map', last_out_label]) # Map output terakhir
        
        # Codec Settings
        cmd.extend(['-c:v', 'libx264', '-preset', 'ultrafast', '-pix_fmt', 'yuv420p'])
        cmd.append(self.output_path)

        self.sig_progress.emit(f"‚öôÔ∏è Command: {' '.join(cmd)}")
        
        # 4. EKSEKUSI
        try:
            startupinfo = None
            if os.name == 'nt':
                startupinfo = subprocess.STARTUPINFO()
                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW

            process = subprocess.Popen(
                cmd, 
                stdout=subprocess.PIPE, 
                stderr=subprocess.PIPE,
                universal_newlines=True,
                startupinfo=startupinfo
            )
            
            stdout, stderr = process.communicate()
            
            if process.returncode == 0:
                self.sig_finished.emit(True, f"Render Selesai: {self.output_path}")
            else:
                # Ambil log error FFmpeg secukupnya
                err_msg = stderr[-800:] if stderr else "Unknown Error"
                self.sig_finished.emit(False, f"Error FFmpeg:\n{err_msg}")
                
        except Exception as e:
            self.sig_finished.emit(False, str(e))

==========================================================================================
FILE: engine\__init__.py
==========================================================================================


==========================================================================================
FILE: engine\caption\assemblyai.py
==========================================================================================
import os
import time
import requests
from dotenv import load_dotenv

load_dotenv()

ASSEMBLYAI_API_KEY = os.getenv("ASSEMBLYAI_API_KEY")
if not ASSEMBLYAI_API_KEY:
    raise RuntimeError("ASSEMBLYAI_API_KEY tidak ditemukan di .env")

AIAI_UPLOAD = "https://api.assemblyai.com/v2/upload"
AIAI_TRANSCRIPT = "https://api.assemblyai.com/v2/transcript"

HEADERS = {
    "authorization": ASSEMBLYAI_API_KEY,
    "content-type": "application/json"
}


def assembly_upload(audio_path):
    headers = {"authorization": ASSEMBLYAI_API_KEY}
    with open(audio_path, "rb") as f:
        r = requests.post(AIAI_UPLOAD, headers=headers, data=f)
    r.raise_for_status()
    return r.json()["upload_url"]


def assembly_transcribe(upload_url, language_code="id"):
    """
    Transcribe audio via AssemblyAI (FULL REST).
    language_code: "id", "en", dll
    """

    # 1Ô∏è‚É£ Create transcript job
    payload = {
        "audio_url": upload_url,
        "language_code": language_code,   # üîë PAKSA BAHASA
        "punctuate": True,
        "format_text": True
    }

    r = requests.post(
        AIAI_TRANSCRIPT,
        headers=HEADERS,
        json=payload
    )
    r.raise_for_status()
    transcript_id = r.json()["id"]

    # 2Ô∏è‚É£ Poll sampai selesai
    while True:
        r = requests.get(
            f"{AIAI_TRANSCRIPT}/{transcript_id}",
            headers=HEADERS
        )
        r.raise_for_status()
        data = r.json()

        status = data["status"]
        if status == "completed":
            break
        if status == "error":
            raise RuntimeError(f"AssemblyAI error: {data['error']}")

        time.sleep(1.5)

    # 3Ô∏è‚É£ Ambil word timestamps
    words = []
    for w in data.get("words", []):
        words.append({
            "word": w["text"],
            "start": w["start"] / 1000.0,
            "end": w["end"] / 1000.0
        })

    return words


==========================================================================================
FILE: engine\caption\ass_builder.py
==========================================================================================
def ass_time(ms):
    total = ms // 1000
    cs = (ms // 10) % 100
    h = total // 3600
    m = (total % 3600) // 60
    s = total % 60
    return f"{h}:{m:02d}:{s:02d}.{cs:02d}"

def chunk_words(words, n):
    buf = []
    for w in words:
        buf.append(w)
        if len(buf) == n:
            yield buf
            buf = []
    if buf:
        yield buf


def ass_color_from_hex(hex_color):
    hex_color = hex_color.lstrip("#")
    r, g, b = hex_color[0:2], hex_color[2:4], hex_color[4:6]
    return f"&H00{b}{g}{r}"


def make_ass_from_words(
    words,
    words_per_event=3,
    font="Arial",
    size=64,
    color="&H00FFFFFF",
    outline=3,
    outline_color="&H00000000",
    align=2,   # 2 = bottom-center
    margin_v=120
):
    ...

    header = f"""
[Script Info]
ScriptType: v4.00+

[V4+ Styles]
Format: Name,Fontname,Fontsize,PrimaryColour,OutlineColour,BorderStyle,Outline,Alignment
Style: Default,{font},{size},{color},{color},1,{outline},2

[Events]
Format: Layer, Start, End, Style, Text
""".strip()

    events = []
    for group in chunk_words(words, words_per_event):
        start = ass_time(group[0]["start"])
        end = ass_time(group[-1]["end"])
        text = " ".join(w["text"] for w in group)
        events.append(f"Dialogue: 0,{start},{end},Default,{text}")

    return header + "\n" + "\n".join(events)


==========================================================================================
FILE: engine\caption\caption_flow.py
==========================================================================================
# engine/caption/caption_flow.py
import os
import subprocess
import tempfile

from engine.caption.assemblyai import assembly_upload, assembly_transcribe
from engine.caption.ass_builder import make_ass_from_words
from engine.caption.subtitle_renderer import burn_subtitle
from engine.caption.lang_detect import detect_language


def extract_audio(video_path, wav_path):
    subprocess.run([
        "ffmpeg", "-y",
        "-i", video_path,
        "-vn",
        "-ac", "1",
        "-ar", "16000",
        wav_path
    ], check=True)


def apply_caption(
    video_path: str,
    output_path: str,
    preset: str = "karaoke"
):
    """
    Apply auto caption to video.
    preset: karaoke | chunk | netflix
    """

    if preset == "karaoke":
        words_per_event = 1
    elif preset == "chunk":
        words_per_event = 3
    else:
        words_per_event = 2

    with tempfile.TemporaryDirectory() as tmp:
        tmp_audio = os.path.join(tmp, "audio.wav")
        tmp_ass = os.path.join(tmp, "caption.ass")

        extract_audio(video_path, tmp_audio)

        lang = detect_language(tmp_audio)
        if lang not in ("id", "en"):
            lang = "id"

        upload_url = assembly_upload(tmp_audio)
        words = assembly_transcribe(upload_url, language_code=lang)

        ass_text = make_ass_from_words(
            words,
            words_per_event=words_per_event
        )

        with open(tmp_ass, "w", encoding="utf-8") as f:
            f.write(ass_text)

        burn_subtitle(video_path, tmp_ass, output_path)


==========================================================================================
FILE: engine\caption\lang_detect.py
==========================================================================================
# engine/caption/lang_detect.py

_model = None

def detect_language(audio_path):
    """
    Deteksi bahasa audio pakai Whisper.
    WAJIB dipanggil sebelum AssemblyAI,
    agar language_code tidak salah aksen.
    """
    global _model

    try:
        import whisper
    except Exception as e:
        raise RuntimeError(
            f"Whisper gagal diimport. "
            f"Pastikan ffmpeg & whisper terinstall dengan benar.\n{e}"
        )

    if _model is None:
        try:
            _model = whisper.load_model("tiny")
        except Exception as e:
            raise RuntimeError(
                f"Gagal load Whisper model.\n{e}"
            )

    try:
        audio = whisper.load_audio(audio_path)
        audio = whisper.pad_or_trim(audio)

        mel = whisper.log_mel_spectrogram(audio).to(_model.device)
        _, probs = _model.detect_language(mel)

        lang = max(probs, key=probs.get)
        return lang
    except Exception as e:
        raise RuntimeError(
            f"Whisper error saat deteksi bahasa.\n{e}"
        )


==========================================================================================
FILE: engine\caption\subtitle_renderer.py
==========================================================================================
import subprocess

def burn_subtitle(video, ass_file, output):
    subprocess.run([
        "ffmpeg", "-y",
        "-i", video,
        "-vf", f"subtitles={ass_file}",
        "-c:a", "copy",
        output
    ], check=True)


==========================================================================================
FILE: engine\caption\word_adapter.py
==========================================================================================
def normalize_words(words):
    """
    Normalize AssemblyAI word list
    (data sudah dalam DETIK)
    """

    out = []

    for w in words:
        text = (
            w.get("text")
            or w.get("word")
            or w.get("punctuated_word")
        )

        if not text:
            continue

        out.append({
            "word": text.upper(),
            "start": float(w["start"]),
            "end": float(w["end"])
        })

    return out


==========================================================================================
FILE: engine\caption\__init__.py
==========================================================================================


==========================================================================================
FILE: engine\effects\move.py
==========================================================================================
from engine.layer_base import Layer
from effects.easing import EASING_MAP

class MoveEffect(Layer):
    def __init__(self, from_x, from_y, to_x, to_y, start, end, easing="linear", enabled=True):
        super().__init__(z_index=0, enabled=enabled, name="MoveEffect")

        self.fx = float(from_x); self.fy = float(from_y)
        self.tx = float(to_x);   self.ty = float(to_y)
        self.start = float(start); self.end = float(end)
        self.easing = EASING_MAP.get(easing, EASING_MAP["linear"])

    def apply(self, frame, frame_index, fps, context):
        t = frame_index / fps

        if t <= self.start:
            p = 0.0
        elif t >= self.end:
            p = 1.0
        else:
            p = (t - self.start) / (self.end - self.start)

        p = self.easing(p)

        context["x"] = int(self.fx + (self.tx - self.fx) * p)
        context["y"] = int(self.fy + (self.ty - self.fy) * p)

        return frame


==========================================================================================
FILE: engine\effects\opacity.py
==========================================================================================
from effects.utils.easing import EASING_MAP
from engine.core.layer_base import Layer


class OpacityEffect(Layer):
    def __init__(self, start, end, from_value=0.0, to_value=1.0, easing="linear"):
        super().__init__(z_index=0, enabled=True, name="Opacity")
        self.start = float(start)
        self.end = float(end)
        self.from_value = float(from_value)
        self.to_value = float(to_value)
        self.easing_fn = EASING_MAP.get(easing, EASING_MAP["linear"])

    def apply(self, frame, frame_index, fps, context: dict):
        t = frame_index / fps

        if self.end <= self.start:
            context["opacity"] = self.to_value
            return frame

        if t <= self.start:
            context["opacity"] = self.from_value
            return frame

        if t >= self.end:
            context["opacity"] = self.to_value
            return frame

        p = (t - self.start) / (self.end - self.start)
        p = max(0.0, min(1.0, self.easing_fn(p)))

        opacity = self.from_value + (self.to_value - self.from_value) * p
        context["opacity"] = max(0.0, min(1.0, opacity))
        return frame


==========================================================================================
FILE: engine\effects\rotate_anim.py
==========================================================================================
from engine.layer_base import Layer
from effects.easing import EASING_MAP

class RotateAnimEffect(Layer):
    def __init__(self, start, end, from_angle, to_angle, easing="ease_out", enabled=True):
        super().__init__(z_index=0, enabled=enabled, name="RotateAnim")

        self.start = float(start)
        self.end = float(end)
        self.from_angle = float(from_angle)
        self.to_angle = float(to_angle)
        self.easing_fn = EASING_MAP.get(easing, EASING_MAP["linear"])

    def apply(self, frame, frame_index, fps, context):
        t = frame_index / fps

        if t < self.start:
            context["rotate"] = self.from_angle
            return frame

        if t > self.end:
            context["rotate"] = self.to_angle
            return frame

        p = (t - self.start) / (self.end - self.start)
        p = max(0.0, min(1.0, p))
        p = self.easing_fn(p)

        context["rotate"] = self.from_angle + (self.to_angle - self.from_angle) * p
        return frame


==========================================================================================
FILE: engine\effects\scale.py
==========================================================================================
from effects.easing import EASING_MAP

class ScaleEffect:
    def __init__(self, from_scale, to_scale, start, end, easing="linear"):
        self.from_scale = float(from_scale)
        self.to_scale = float(to_scale)
        self.start = float(start)
        self.end = float(end)
        self.easing = EASING_MAP.get(easing, EASING_MAP["linear"])

    def apply(self, frame, frame_index, fps, context):
        t = frame_index / fps

        # ‚õî DI LUAR WINDOW ‚Üí JANGAN SENTUH CONTEXT
        if t < self.start or t > self.end:
            return frame

        # hitung progress
        p = (t - self.start) / (self.end - self.start)
        p = max(0.0, min(1.0, p))
        p = self.easing(p)

        scale = self.from_scale + (self.to_scale - self.from_scale) * p

        # tulis hanya saat aktif
        context["scale"] = max(0.01, scale)
        return frame


==========================================================================================
FILE: engine\effects\scale_popup.py
==========================================================================================
from effects.easing import EASING_MAP

class ScalePopupEffect:
    def __init__(
        self,
        start,
        end,
        from_scale=0.05,
        to_scale=1.0,
        easing="ease_out_back"
    ):
        self.start = float(start)
        self.end = float(end)
        self.from_scale = float(from_scale)
        self.to_scale = float(to_scale)
        self.easing_fn = EASING_MAP.get(easing, EASING_MAP["linear"])

    def apply(self, frame, frame_index, fps, context):
        t = frame_index / fps

        if t < self.start:
            context["scale"] = self.from_scale
            return frame

        if t > self.end:
            context["scale"] = self.to_scale
            return frame

        # progress linear
        p = (t - self.start) / (self.end - self.start)
        p = max(0.0, min(1.0, p))

        # ‚ú® easing applied here
        p = self.easing_fn(p)

        scale = self.from_scale + (self.to_scale - self.from_scale) * p
        context["scale"] = scale
        return frame


==========================================================================================
FILE: engine\effects\simple_text_renderer.py
==========================================================================================
import numpy as np
from PIL import Image, ImageDraw, ImageFont

class SimpleTextRenderer:
    @staticmethod
    def render(settings):
        """
        Menerima dictionary settings, mengembalikan Numpy Array (H, W, 4) RGBA.
        Pure Python logic, independen dari GUI Qt.
        """
        # 1. Konfigurasi Canvas (Resolusi Tinggi untuk Preview Tajam)
        width, height = 1080, 1080 
        # Mode RGBA (Transparent Background)
        img = Image.new('RGBA', (width, height), (0, 0, 0, 0))
        draw = ImageDraw.Draw(img)
        
        # 2. Ambil Data dari Settings
        text = settings.get("text_content", "Sample Text")
        font_family = settings.get("font_family", "Arial")
        font_size = int(settings.get("font_size", 80))
        color_hex = settings.get("text_color", "#ffffff")
        align = settings.get("text_align", "center") # left, center, right
        is_paragraph = settings.get("is_paragraph", False)
        
        # 3. Load Font (Fallback mechanism)
        font = None
        try:
            # Coba load font sistem (Windows/Linux path berbeda, ini basic attempt)
            # Idealnya menggunakan library font manager, tapi ini cukup untuk basic
            font = ImageFont.truetype(f"{font_family}.ttf", font_size)
        except OSError:
            try:
                font = ImageFont.truetype("arial.ttf", font_size)
            except OSError:
                font = ImageFont.load_default()

        # 4. Parsing Warna (#RRGGBB -> RGB)
        color_hex = color_hex.lstrip('#')
        if len(color_hex) == 6:
            rgb = tuple(int(color_hex[i:i+2], 16) for i in (0, 2, 4)) + (255,) # + Alpha 255
        else:
            rgb = (255, 255, 255, 255)

        # 5. Logika Posisi (Layouting)
        # PIL Anchor: 'mm' = middle-middle, 'lm' = left-middle, etc.
        xy = (width/2, height/2)
        anchor = "mm"
        align_pil = "center" # Parameter align untuk multiline text di PIL
        
        if is_paragraph:
            # Mode Paragraf (Multiline support dari PIL)
            if align == "left":
                xy = (50, height/2) # Padding kiri
                anchor = "lm"
                align_pil = "left"
            elif align == "right":
                xy = (width-50, height/2)
                anchor = "rm"
                align_pil = "right"
            else:
                align_pil = "center"
        else:
            # Mode Judul Singkat
            if align == "left": 
                anchor = "lm"
                xy = (width/2 - 200, height/2) # Offset visual
            elif align == "right":
                anchor = "rm"
                xy = (width/2 + 200, height/2)
            
        # 6. Gambar Teks ke Image
        draw.text(
            xy, 
            text, 
            font=font, 
            fill=rgb, 
            anchor=anchor, 
            align=align_pil
        )
        
        # 7. Konversi ke Numpy Array
        # Return array uint8 (Height, Width, Channels)
        return np.array(img)

==========================================================================================
FILE: engine\effects\text_advanced.py
==========================================================================================
import os
import cv2
import numpy as np
from PIL import Image, ImageDraw, ImageFont
from engine.core.layer_base import Layer
from utils.paths import project_path
from effects.utils.easing import ease_value


class TextAdvancedEffect(Layer):
    def __init__(
        self,
        text,
        x,
        y,
        font_path,
        font_size=32,
        color=(255, 255, 255),
        opacity=1.0,
        z_index=0,
        enabled=True,
        align="left",
        stroke_width=0,
        stroke_color=(0, 0, 0),
    ):
        super().__init__(z_index=z_index, enabled=enabled, name="TextAdvanced")

        if not hasattr(self, "transform"):
            raise RuntimeError("LayerBase HARUS membuat self.transform sebelum TextAdvancedEffect")

        # Transform
        self.transform.x = int(x)
        self.transform.y = int(y)
        if self.transform.scale == 0:
            self.transform.scale = 1.0

        # Text props
        self.text = text
        self.font_path = font_path
        self.full_font_path = project_path(font_path)
        self.base_font_size = int(font_size)
        self.color = tuple(color)
        self.base_opacity = float(opacity)
        self.align = align
        self.stroke_width = int(stroke_width)
        self.stroke_color = tuple(stroke_color)
        self.padding = 10

        # Cache
        self._cached_surface = None
        self._cached_rotated = None
        self._cache_params = None
        self._last_rotation = None
        self._w_orig = 0
        self._h_orig = 0
        
        # Motion easing untuk drag
        self._target_x = x
        self._target_y = y
        self._easing_factor = 0.35  # Smoothing factor

    # -------------------------------------------------

    def _render_text_bitmap(self, scale):
        if not self.font_path or not os.path.exists(self.full_font_path):
            return None

        size = max(1, int(self.base_font_size * scale))

        try:
            font = ImageFont.truetype(self.full_font_path, size)
        except Exception:
            font = ImageFont.load_default()

        left, top, right, bottom = font.getbbox(self.text)
        text_w = right - left
        text_h = bottom - top

        pad = int(self.stroke_width * scale * 2) + self.padding
        img_w = int(text_w + pad * 2)
        img_h = int(text_h + pad * 2)

        img = Image.new("RGBA", (img_w, img_h), (0, 0, 0, 0))
        draw = ImageDraw.Draw(img)

        x_txt = pad - left
        y_txt = pad - top

        # Stroke
        if self.stroke_width > 0:
            sw = int(self.stroke_width * scale)
            for dx in range(-sw, sw + 1):
                for dy in range(-sw, sw + 1):
                    if dx * dx + dy * dy > sw * sw:
                        continue
                    draw.text((x_txt + dx, y_txt + dy), self.text, font=font, fill=self.stroke_color)

        # Fill
        draw.text((x_txt, y_txt), self.text, font=font, fill=self.color)

        self._w_orig = img_w
        self._h_orig = img_h

        return np.array(img)

    # -------------------------------------------------

    def apply(self, frame, frame_index, fps, context: dict):
        # === Adaptive color ===
        adaptive = context.get("adaptive_text", {}).get("color")
        if adaptive is not None and adaptive != self.color:
            self.color = adaptive
            self._cached_surface = None

        scale = self.transform.scale
        rot = getattr(self.transform, "rotation", 0)

        cache_key = (
            self.text,
            self.font_path,
            self.color,
            self.stroke_width,
            self.stroke_color,
            round(scale, 3),
        )

        # Render bitmap
        if self._cached_surface is None or self._cache_params != cache_key:
            surf = self._render_text_bitmap(scale)
            if surf is None:
                return frame
            self._cached_surface = surf
            self._cache_params = cache_key
            self._cached_rotated = None
            self._last_rotation = None

        # Rotate cache
        if self._cached_rotated is None or self._last_rotation != rot:
            if rot == 0:
                self._cached_rotated = self._cached_surface
            else:
                pil = Image.fromarray(self._cached_surface)
                pil = pil.rotate(rot, expand=True, resample=Image.BICUBIC)
                self._cached_rotated = np.array(pil)
            self._last_rotation = rot

        overlay = self._cached_rotated
        if overlay is None:
            return frame

        h, w = overlay.shape[:2]

        cx = self.transform.x + self._w_orig / 2
        cy = self.transform.y + self._h_orig / 2
        px = int(cx - w / 2)
        py = int(cy - h / 2)

        fh, fw = frame.shape[:2]
        x1, y1 = max(0, px), max(0, py)
        x2, y2 = min(fw, px + w), min(fh, py + h)

        if x1 >= x2 or y1 >= y2:
            return frame

        ox1, oy1 = x1 - px, y1 - py
        ox2, oy2 = ox1 + (x2 - x1), oy1 + (y2 - y1)

        roi = frame[y1:y2, x1:x2]
        ov = overlay[oy1:oy2, ox1:ox2]

        alpha = ov[:, :, 3:4].astype(np.float32) / 255.0
        alpha *= self.base_opacity
        alpha *= float(context.get("opacity", 1.0))
        alpha = np.clip(alpha, 0.0, 1.0)

        rgb = ov[:, :, :3].astype(np.float32)
        bg = roi.astype(np.float32)

        roi[:] = (alpha * rgb + (1.0 - alpha) * bg).astype(np.uint8)
        return frame

    # -------------------------------------------------

    def get_bbox(self):
        if self._cached_surface is None:
            self._render_text_bitmap(self.transform.scale)

        w = self._w_orig + self.padding * 2
        h = self._h_orig + self.padding * 2

        return (
            int(self.transform.x - self.padding),
            int(self.transform.y - self.padding),
            int(w),
            int(h),
        )

    # di TextAdvancedEffect

    def set_drag_target(self, target_x, target_y):
        """Set target position untuk easing saat drag."""
        self._target_x = float(target_x)
        self._target_y = float(target_y)
    
    def set_easing_factor(self, factor):
        """Set faktor smoothing (0.1-0.9), lebih rendah = lebih smooth."""
        self._easing_factor = max(0.01, min(0.99, float(factor)))
    
    def update_with_easing(self):
        """Update posisi dengan motion easing exponential."""
        self.transform.x += (self._target_x - self.transform.x) * self._easing_factor
        self.transform.y += (self._target_y - self.transform.y) * self._easing_factor

    def draw_fast(self, frame):
        """
        Super-fast preview draw dengan alpha mask (TANPA alpha blend float).
        Aman, HALUS, TANPA background hitam.
        Includes motion easing untuk smooth drag.
        """
        if self._cached_surface is None:
            self._render_text_bitmap(self.transform.scale)

        if self._cached_surface is None:
            return frame

        # Update posisi dengan easing
        self.update_with_easing()

        overlay = self._cached_surface
        h, w = overlay.shape[:2]

        fh, fw = frame.shape[:2]
        x = int(self.transform.x)
        y = int(self.transform.y)
        x1 = max(0, x)
        y1 = max(0, y)
        x2 = min(fw, x + w)
        y2 = min(fh, y + h)

        if x1 >= x2 or y1 >= y2:
            return frame

        ox1 = x1 - x
        oy1 = y1 - y
        ox2 = ox1 + (x2 - x1)
        oy2 = oy1 + (y2 - y1)

        ov = overlay[oy1:oy2, ox1:ox2]
        rgb = ov[..., :3]
        alpha = ov[..., 3]

        mask = alpha > 0

        roi = frame[y1:y2, x1:x2]
        roi[mask] = rgb[mask]

        return frame


==========================================================================================
FILE: engine\effects\text_karaoke_bounce.py
==========================================================================================
import math
import numpy as np
from PIL import Image, ImageDraw, ImageFont
from effects.easing import ease_out_back


class KaraokeBounceScaleEffect:
    """
    Karaoke subtitle dengan bounce + scale pada kata aktif.
    Cocok dikombinasikan dengan highlight / gradient.
    """

    def __init__(
        self,
        text,
        x,
        y,
        start,
        end,
        max_width,
        anchor="center",
        line_spacing=10,

        font_path="assets/fonts/Montserrat-Bold.ttf",
        font_size=40,

        base_color=(200, 200, 200),
        active_color=(255, 255, 255),

        scale_from=1.0,
        scale_to=1.25,
        bounce_strength=0.35,   # semakin besar ‚Üí makin pop

        z_index=0
    ):
        self.text = text
        self.words = text.split(" ")

        self.x = x
        self.y = y
        self.start = float(start)
        self.end = float(end)
        self.max_width = max_width
        self.anchor = anchor
        self.line_spacing = int(line_spacing)

        self.font_path = font_path
        self.font_size = font_size

        self.base_color = base_color
        self.active_color = active_color

        self.scale_from = float(scale_from)
        self.scale_to = float(scale_to)
        self.bounce_strength = float(bounce_strength)

        self.z_index = z_index

        self._font_base = ImageFont.truetype(font_path, font_size)
        self._lines = None

    # --------------------------------------------------

    def _compute_lines(self, draw, max_w):
        space_w = draw.textbbox((0, 0), " ", font=self._font_base)[2]
        lines = []
        cur_words = []
        cur_w = 0

        for word in self.words:
            bw = draw.textbbox((0, 0), word, font=self._font_base)[2]
            next_w = bw if not cur_words else cur_w + space_w + bw

            if next_w <= max_w:
                cur_words.append(word)
                cur_w = next_w
            else:
                lines.append(cur_words)
                cur_words = [word]
                cur_w = bw

        if cur_words:
            lines.append(cur_words)

        return lines

    # --------------------------------------------------

    def apply(self, frame, frame_index, fps, context):
        t = frame_index / fps
        if t < self.start:
            return frame

        p = (t - self.start) / (self.end - self.start)
        p = max(0.0, min(1.0, p))

        total_words = len(self.words)
        if total_words == 0:
            return frame

        active_word = min(total_words - 1, int(p * total_words))

        h, w = frame.shape[:2]
        px = self._resolve(self.x, w)
        py = self._resolve(self.y, h)

        base = Image.fromarray(frame).convert("RGBA")
        layer = Image.new("RGBA", base.size, (0, 0, 0, 0))
        draw = ImageDraw.Draw(layer)

        # resolve max width
        if isinstance(self.max_width, str) and self.max_width.endswith("%"):
            max_w = int(float(self.max_width[:-1]) / 100 * w)
        else:
            max_w = int(self.max_width)

        # precompute wrap
        if self._lines is None:
            self._lines = self._compute_lines(draw, max_w)

        # metrics
        bbox = draw.textbbox((0, 0), "Hg", font=self._font_base)
        line_h = bbox[3] - bbox[1]
        total_h = len(self._lines) * line_h + (len(self._lines) - 1) * self.line_spacing

        start_y = py - total_h // 2 if self.anchor == "center" else py

        word_idx = 0
        y = start_y

        for line_words in self._lines:
            widths = [draw.textbbox((0, 0), w, font=self._font_base)[2] for w in line_words]
            space_w = draw.textbbox((0, 0), " ", font=self._font_base)[2]
            line_w = sum(widths) + space_w * (len(widths) - 1)

            x = px - line_w // 2 if self.anchor == "center" else px
            cx = x

            for i, word in enumerate(line_words):
                is_active = (word_idx == active_word)

                # scale bounce
                if is_active:
                    bounce_p = ease_out_back(1.0)
                    scale = self.scale_from + (self.scale_to - self.scale_from) * bounce_p
                    font = ImageFont.truetype(
                        self.font_path,
                        int(self.font_size * scale)
                    )
                    color = self.active_color
                else:
                    font = self._font_base
                    color = self.base_color

                draw.text(
                    (cx, y),
                    word,
                    font=font,
                    fill=color + (255,)
                )

                bw = draw.textbbox((0, 0), word, font=font)[2]
                cx += bw + space_w
                word_idx += 1

            y += line_h + self.line_spacing

        out = Image.alpha_composite(base, layer)
        return np.array(out.convert("RGB"))

    # --------------------------------------------------

    def _resolve(self, value, max_value):
        if isinstance(value, str) and value.endswith("%"):
            return int(float(value[:-1]) / 100 * max_value)
        return int(value)


==========================================================================================
FILE: engine\effects\text_karaoke_chunk.py
==========================================================================================
import numpy as np
from PIL import Image, ImageDraw, ImageFont
from engine.core.layer_base import Layer
from utils.paths import project_path


class KaraokeChunkTimestampEffect(Layer):
    """
    Karaoke subtitle CHUNK MODE (non-overlapping).
    Menampilkan N kata sekaligus, lalu lompat ke chunk berikutnya.
    """

    def __init__(
        self,
        words,
        x,
        y,
        chunk_size=3,
        anchor="center",
        font_path="assets/fonts/Montserrat-Bold.ttf",
        font_size=42,
        base_color=(200, 200, 200),
        active_color=(0, 0, 0),
        highlight_color=(255, 215, 0),
        padding_x=10,
        padding_y=6,
        radius=8,
        z_index=0,
        enabled=True
    ):
        super().__init__(z_index=z_index, enabled=enabled, name="KaraokeChunk")

        self.words_data = words
        self.x = x
        self.y = y
        self.chunk_size = int(chunk_size)
        self.anchor = anchor

        self.font_path = project_path(font_path)
        self.font_size = font_size
        self._font = ImageFont.truetype(self.font_path, font_size)

        self.base_color = base_color
        self.active_color = active_color
        self.highlight_color = highlight_color

        self.padding_x = int(padding_x)
        self.padding_y = int(padding_y)
        self.radius = int(radius)

        # Precompute chunk ranges
        self.chunks = []
        for i in range(0, len(words), self.chunk_size):
            chunk = words[i:i + self.chunk_size]
            self.chunks.append({
                "start": chunk[0]["start"],
                "end": chunk[-1]["end"],
                "words": [w["word"] for w in chunk]
            })

    # --------------------------------------------------

    def apply(self, frame, frame_index, fps, context):
        t = frame_index / fps

        active_chunk = None
        for ch in self.chunks:
            if ch["start"] <= t <= ch["end"]:
                active_chunk = ch
                break

        if active_chunk is None:
            return frame

        opacity = int(255 * float(context.get("opacity", 1.0)))

        h, w = frame.shape[:2]
        px = self._resolve(self.x, w)
        py = self._resolve(self.y, h)

        base = Image.fromarray(frame).convert("RGBA")
        layer = Image.new("RGBA", base.size, (0, 0, 0, 0))
        draw = ImageDraw.Draw(layer)

        words = active_chunk["words"]
        widths = [draw.textbbox((0, 0), w, font=self._font)[2] for w in words]
        space_w = draw.textbbox((0, 0), " ", font=self._font)[2]
        line_w = sum(widths) + space_w * (len(widths) - 1)

        bbox = draw.textbbox((0, 0), "Hg", font=self._font)
        line_h = bbox[3] - bbox[1]

        x = px - line_w // 2 if self.anchor == "center" else px
        y = py

        cx = x
        for i, word in enumerate(words):
            bw = widths[i]

            draw.rounded_rectangle(
                [
                    cx - self.padding_x,
                    y - self.padding_y,
                    cx + bw + self.padding_x,
                    y + line_h + self.padding_y
                ],
                radius=self.radius,
                fill=self.highlight_color + (opacity,)
            )

            draw.text(
                (cx, y),
                word,
                font=self._font,
                fill=self.active_color + (opacity,)
            )

            cx += bw + space_w

        out = Image.alpha_composite(base, layer)
        return np.array(out.convert("RGB"))

    # --------------------------------------------------

    def _resolve(self, value, max_value):
        if isinstance(value, str) and value.endswith("%"):
            return int(float(value[:-1]) / 100 * max_value)
        return int(value)


==========================================================================================
FILE: engine\effects\composite\blend.py
==========================================================================================
from engine.core.layer_base import Layer
from utils.blend_modes import BLEND_MODES


class BlendEffect(Layer):
    def __init__(self, mode="normal", opacity=1.0, start=0.0, end=None):
        super().__init__(z_index=0, enabled=True, name="Blend")
        self.mode = mode
        self.opacity = float(opacity)
        self.start = float(start)
        self.end = float(end) if end is not None else None

    def apply(self, frame, frame_index, fps, context: dict):
        t = frame_index / fps

        if t < self.start:
            return frame
        if self.end is not None and t > self.end:
            return frame

        base_frame = context.get("base_frame", frame)


        blend_func = BLEND_MODES.get(self.mode)
        if blend_func is None:
            return frame

        global_opacity = float(context.get("opacity", 1.0))
        final_opacity = max(0.0, min(1.0, self.opacity * global_opacity))

        try:
            return blend_func(base_frame, frame, final_opacity)
        except Exception:
            return frame


==========================================================================================
FILE: engine\effects\composite\blur_feather_rounded.py
==========================================================================================
import cv2
import numpy as np
from engine.core.layer_base import Layer


class BlurFeatherRoundedEffect(Layer):
    """
    Blur area dengan feather + rounded corner.
    """

    def __init__(
        self,
        x,
        y,
        width,
        height,
        blur_strength=31,
        corner_radius=30,
        feather=20,
        start_frame=0,
        end_frame=None,
        z_index=0,
        enabled=True
    ):
        super().__init__(z_index=z_index, enabled=enabled, name="BlurFeatherRounded")

        self.x = int(x)
        self.y = int(y)
        self.w = int(width)
        self.h = int(height)

        if blur_strength % 2 == 0:
            blur_strength += 1
        self.blur_strength = blur_strength

        self.corner_radius = int(corner_radius)
        self.feather = int(feather)

        self.start_frame = start_frame
        self.end_frame = end_frame

    def _rounded_rect_mask(self, shape):
        mask = np.zeros(shape[:2], dtype=np.uint8)

        x1, y1 = self.x, self.y
        x2, y2 = self.x + self.w, self.y + self.h
        r = min(self.corner_radius, self.w // 2, self.h // 2)

        cv2.rectangle(mask, (x1 + r, y1), (x2 - r, y2), 255, -1)
        cv2.rectangle(mask, (x1, y1 + r), (x2, y2 - r), 255, -1)

        cv2.circle(mask, (x1 + r, y1 + r), r, 255, -1)
        cv2.circle(mask, (x2 - r, y1 + r), r, 255, -1)
        cv2.circle(mask, (x1 + r, y2 - r), r, 255, -1)
        cv2.circle(mask, (x2 - r, y2 - r), r, 255, -1)

        return mask

    def apply(self, frame, frame_index, fps, context: dict):
        if frame_index < self.start_frame:
            return frame
        if self.end_frame is not None and frame_index > self.end_frame:
            return frame

        blurred = cv2.GaussianBlur(
            frame,
            (self.blur_strength, self.blur_strength),
            0
        )

        mask = self._rounded_rect_mask(frame.shape)

        if self.feather > 0:
            k = self.feather * 2 + 1
            mask = cv2.GaussianBlur(mask, (k, k), 0)

        alpha = mask.astype(float) / 255.0
        alpha = cv2.merge([alpha, alpha, alpha])

        out = frame * (1 - alpha) + blurred * alpha
        return out.astype(np.uint8)


==========================================================================================
FILE: engine\effects\composite\blur_region.py
==========================================================================================
import cv2
from engine.core.layer_base import Layer


class BlurRegionEffect(Layer):
    """
    Blur area tertentu pada video.
    Cocok untuk menutup subtitle / watermark video asli.
    """

    def __init__(
        self,
        x,
        y,
        width,
        height,
        blur_strength=25,
        start_frame=0,
        end_frame=None,
        z_index=0,
        enabled=True
    ):
        super().__init__(z_index=z_index, enabled=enabled, name="BlurRegion")

        self.x = int(x)
        self.y = int(y)
        self.w = int(width)
        self.h = int(height)

        if blur_strength % 2 == 0:
            blur_strength += 1
        self.blur_strength = blur_strength

        self.start_frame = start_frame
        self.end_frame = end_frame

    def apply(self, frame, frame_index, fps, context: dict):
        if frame_index < self.start_frame:
            return frame
        if self.end_frame is not None and frame_index > self.end_frame:
            return frame

        h, w = frame.shape[:2]

        x1 = max(0, self.x)
        y1 = max(0, self.y)
        x2 = min(w, self.x + self.w)
        y2 = min(h, self.y + self.h)

        if x2 <= x1 or y2 <= y1:
            return frame

        roi = frame[y1:y2, x1:x2]
        blurred = cv2.GaussianBlur(
            roi,
            (self.blur_strength, self.blur_strength),
            0
        )

        frame[y1:y2, x1:x2] = blurred
        return frame


==========================================================================================
FILE: engine\effects\composite\chroma_key.py
==========================================================================================
from engine.core.layer_base import Layer
from effects.composite.chroma.chroma_math import chroma_key_rgba


class ChromaKeyEffect(Layer):
    def __init__(self, key_color=(0,255,0), threshold=40, softness=10, z_index=0, enabled=True):
        super().__init__(z_index=z_index, enabled=enabled, name="ChromaKey")
        self.key_color = key_color
        self.threshold = threshold
        self.softness = softness


    def apply(self, frame, frame_index, fps, context):
        out = chroma_key_rgba(
            frame,
            self.key_color,
            self.threshold,
            self.softness
        )
        context["force_bgra"] = True
        return out


==========================================================================================
FILE: engine\effects\composite\despill.py
==========================================================================================
from engine.core.layer_base import Layer
from effects.composite.chroma.despill_math import despill_rgba


class DespillEffect(Layer):
    def __init__(self, strength=0.5, z_index=0, enabled=True):
        super().__init__(z_index=z_index, enabled=enabled, name="Despill")
        self.strength = strength

    def apply(self, frame, frame_index, fps, context):
        if frame.shape[2] != 4:
            return frame
        return despill_rgba(frame, self.strength)


==========================================================================================
FILE: engine\effects\composite\image_overlay.py
==========================================================================================
import cv2
import numpy as np
from engine.core.layer_base import Layer


class ImageOverlayEffect(Layer):
    def __init__(self, x=0, y=0, scale=1.0, z_index=0, enabled=True):
        super().__init__(z_index=z_index, enabled=enabled, name="ImageOverlay")
        self.x = int(x)
        self.y = int(y)
        self.scale = float(scale)

    def apply(self, frame, frame_index, fps, context):
        overlay = context.get("overlay_frame")
        if overlay is None:
            return frame

        if overlay.ndim != 3 or overlay.shape[2] not in (3, 4):
            return frame

        h_bg, w_bg = frame.shape[:2]

        if self.scale != 1.0:
            overlay = cv2.resize(
                overlay, None,
                fx=self.scale, fy=self.scale,
                interpolation=cv2.INTER_LINEAR
            )

        h_ov, w_ov = overlay.shape[:2]

        x1 = max(self.x, 0)
        y1 = max(self.y, 0)
        x2 = min(self.x + w_ov, w_bg)
        y2 = min(self.y + h_ov, h_bg)

        if x1 >= x2 or y1 >= y2:
            return frame

        ov_x1 = x1 - self.x
        ov_y1 = y1 - self.y
        ov_x2 = ov_x1 + (x2 - x1)
        ov_y2 = ov_y1 + (y2 - y1)

        roi_bg = frame[y1:y2, x1:x2]
        roi_ov = overlay[ov_y1:ov_y2, ov_x1:ov_x2]

        if roi_ov.shape[2] == 4:
            alpha = roi_ov[:, :, 3:4].astype(np.float32) / 255.0
            alpha *= float(context.get("opacity", 1.0))
            alpha = np.clip(alpha, 0.0, 1.0)

            rgb = roi_ov[:, :, :3].astype(np.float32)
            bg = roi_bg.astype(np.float32)

            blended = alpha * rgb + (1.0 - alpha) * bg
            frame[y1:y2, x1:x2] = blended.astype(np.uint8)
        else:
            frame[y1:y2, x1:x2] = roi_ov

        # prevent overlay carry-over
        context["overlay_frame"] = None
        return frame



==========================================================================================
FILE: engine\effects\composite\mask_image.py
==========================================================================================
import cv2
import numpy as np
from engine.core.layer_base import Layer


class ImageMaskEffect(Layer):
    """
    Image-based mask (grayscale / alpha).
    Putih = terlihat, hitam = transparan.
    """

    def __init__(
        self,
        mask_path,
        x="50%",
        y="50%",
        scale=1.0,
        feather=0,
        invert=False,
        z_index=-50,
        enabled=True,
    ):
        super().__init__(z_index=z_index, enabled=enabled, name="ImageMask")

        self.mask_path = mask_path
        self.x = x
        self.y = y
        self.scale = float(scale)
        self.feather = int(feather)
        self.invert = invert

        self._mask_img = None

    # --------------------------------------------------

    def apply(self, frame, frame_index, fps, context):
        if self._mask_img is None:
            self._mask_img = cv2.imread(self.mask_path, cv2.IMREAD_GRAYSCALE)
            if self._mask_img is None:
                return frame

        h, w = frame.shape[:2]
        cx = self._resolve(self.x, w)
        cy = self._resolve(self.y, h)

        mask = self._mask_img.copy()

        if self.scale != 1.0:
            mask = cv2.resize(
                mask,
                None,
                fx=self.scale,
                fy=self.scale,
                interpolation=cv2.INTER_LINEAR
            )

        mh, mw = mask.shape[:2]

        canvas = np.zeros((h, w), dtype=np.uint8)
        x0 = cx - mw // 2
        y0 = cy - mh // 2
        x1 = x0 + mw
        y1 = y0 + mh

        sx0 = max(0, -x0)
        sy0 = max(0, -y0)
        sx1 = mw - max(0, x1 - w)
        sy1 = mh - max(0, y1 - h)

        tx0 = max(0, x0)
        ty0 = max(0, y0)
        tx1 = tx0 + (sx1 - sx0)
        ty1 = ty0 + (sy1 - sy0)

        canvas[ty0:ty1, tx0:tx1] = mask[sy0:sy1, sx0:sx1]

        if self.feather > 0:
            k = self.feather * 2 + 1
            canvas = cv2.GaussianBlur(canvas, (k, k), 0)

        if self.invert:
            canvas = 255 - canvas

        if frame.shape[2] == 3:
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2BGRA)
            context["force_bgra"] = True

        alpha = frame[:, :, 3].astype(np.float32)
        mask_f = canvas.astype(np.float32) / 255.0
        opacity = float(context.get("opacity", 1.0))
        frame[:, :, 3] = (alpha * mask_f * opacity).astype(np.uint8)


        return frame

    def _resolve(self, value, max_value):
        if isinstance(value, str) and value.endswith("%"):
            return int(float(value[:-1]) / 100 * max_value)
        return int(value)


==========================================================================================
FILE: engine\effects\composite\mask_shape.py
==========================================================================================
import cv2
import numpy as np
from engine.core.layer_base import Layer


class ShapeMaskEffect(Layer):
    def __init__(
        self,
        shape="rect",
        x="50%",
        y="50%",
        width=400,
        height=300,
        radius=40,
        feather=0,
        invert=False,
        enabled=True,
        z_index=-50
    ):
        super().__init__(z_index=z_index, enabled=enabled, name="ShapeMask")
        self.shape = shape
        self.x = x
        self.y = y
        self.width = int(width)
        self.height = int(height)
        self.radius = int(radius)
        self.feather = int(feather)
        self.invert = invert

    def apply(self, frame, frame_index, fps, context):
        opacity = float(context.get("opacity", 1.0))
        opacity = max(0.0, min(1.0, opacity))

        if opacity <= 0:
            return frame

        if frame.shape[2] == 3:
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2BGRA)

        h, w = frame.shape[:2]
        cx = self._resolve(self.x, w)
        cy = self._resolve(self.y, h)

        mask = np.zeros((h, w), dtype=np.uint8)

        if self.shape == "rect":
            x0 = cx - self.width // 2
            y0 = cy - self.height // 2
            x1 = cx + self.width // 2
            y1 = cy + self.height // 2
            cv2.rectangle(mask, (x0, y0), (x1, y1), 255, -1)

        elif self.shape == "round_rect":
            self._draw_round_rect(mask, cx, cy)

        elif self.shape == "circle":
            r = min(self.width, self.height) // 2
            cv2.circle(mask, (cx, cy), r, 255, -1)

        if self.feather > 0:
            k = self.feather * 2 + 1
            mask = cv2.GaussianBlur(mask, (k, k), 0)

        if self.invert:
            mask = 255 - mask

        alpha = frame[:, :, 3].astype(np.float32)
        mask_f = (mask.astype(np.float32) / 255.0) * opacity
        frame[:, :, 3] = np.clip(alpha * mask_f, 0, 255).astype(np.uint8)

        return frame

    def _draw_round_rect(self, mask, cx, cy):
        w, h = self.width, self.height
        r = min(self.radius, w // 2, h // 2)

        x0 = cx - w // 2
        y0 = cy - h // 2
        x1 = cx + w // 2
        y1 = cy + h // 2

        cv2.rectangle(mask, (x0 + r, y0), (x1 - r, y1), 255, -1)
        cv2.rectangle(mask, (x0, y0 + r), (x1, y1 - r), 255, -1)

        cv2.circle(mask, (x0 + r, y0 + r), r, 255, -1)
        cv2.circle(mask, (x1 - r, y0 + r), r, 255, -1)
        cv2.circle(mask, (x0 + r, y1 - r), r, 255, -1)
        cv2.circle(mask, (x1 - r, y1 - r), r, 255, -1)

    def _resolve(self, value, max_value):
        if isinstance(value, str) and value.endswith("%"):
            return int(float(value[:-1]) / 100 * max_value)
        return int(value)


==========================================================================================
FILE: engine\effects\composite\opacity.py
==========================================================================================
from effects.utils.easing import EASING_MAP
from engine.core.layer_base import Layer


class OpacityEffect(Layer):
    def __init__(self, start, end, from_value=0.0, to_value=1.0, easing="linear"):
        super().__init__(z_index=0, enabled=True, name="Opacity")
        self.start = float(start)
        self.end = float(end)
        self.from_value = float(from_value)
        self.to_value = float(to_value)
        self.easing_fn = EASING_MAP.get(easing, EASING_MAP["linear"])

    def apply(self, frame, frame_index, fps, context: dict):
        t = frame_index / fps

        if self.end <= self.start:
            context["opacity"] = self.to_value
            return frame

        if t <= self.start:
            context["opacity"] = self.from_value
            return frame

        if t >= self.end:
            context["opacity"] = self.to_value
            return frame

        p = (t - self.start) / (self.end - self.start)
        p = max(0.0, min(1.0, self.easing_fn(p)))

        opacity = self.from_value + (self.to_value - self.from_value) * p
        context["opacity"] = max(0.0, min(1.0, opacity))
        return frame


==========================================================================================
FILE: engine\effects\composite\chroma\chroma_math.py
==========================================================================================
import numpy as np
import cv2


def chroma_key_rgba(
    frame,
    key_color=(0, 255, 0),   # BGR
    threshold=40,
    softness=10
):
    """
    Apply chroma key and return BGRA frame.
    - frame: BGR or BGRA (uint8)
    - key_color: (B, G, R)
    """

    if frame.ndim != 3 or frame.shape[2] not in (3, 4):
        return frame

    # Convert to BGR
    if frame.shape[2] == 4:
        bgr = frame[:, :, :3].astype(np.float32)
    else:
        bgr = frame.astype(np.float32)

    key = np.array(key_color, dtype=np.float32)

    # Distance from key color
    diff = np.linalg.norm(bgr - key, axis=2)

    # Alpha mask
    alpha = np.clip(
        (diff - threshold) / max(softness, 1e-5),
        0.0,
        1.0
    )

    alpha = (alpha * 255).astype(np.uint8)

    # Build BGRA
    bgra = np.zeros((bgr.shape[0], bgr.shape[1], 4), dtype=np.uint8)
    bgra[:, :, :3] = np.clip(bgr, 0, 255).astype(np.uint8)
    bgra[:, :, 3] = alpha

    return bgra


==========================================================================================
FILE: engine\effects\composite\chroma\despill_math.py
==========================================================================================
import numpy as np


def despill_rgba(bgra, strength=0.5):
    """
    Reduce green spill on BGRA frame.
    - bgra: BGRA uint8
    - strength: 0.0 ‚Äì 1.0
    """

    if bgra.ndim != 3 or bgra.shape[2] != 4:
        return bgra

    strength = float(np.clip(strength, 0.0, 1.0))

    rgb = bgra[:, :, :3].astype(np.float32)
    alpha = bgra[:, :, 3:4]

    b = rgb[:, :, 0]
    g = rgb[:, :, 1]
    r = rgb[:, :, 2]

    avg_rb = (r + b) * 0.5
    g_new = g * (1.0 - strength) + avg_rb * strength

    rgb[:, :, 1] = g_new
    rgb = np.clip(rgb, 0, 255).astype(np.uint8)

    return np.concatenate([rgb, alpha], axis=2)


==========================================================================================
FILE: engine\effects\composite\chroma\__init__.py
==========================================================================================


==========================================================================================
FILE: gui\dummy_engine.py
==========================================================================================
# engine/dummy_engine.py
import numpy as np

class DummyEngine:
    """
    Mesin palsu untuk pengembangan UI.
    Tidak memproses video, hanya mencetak log ke terminal.
    """
    def __init__(self):
        print("[ENGINE] Dummy Engine Started (UI Mode)")
        self.clips = []

    def sync_clips(self, clips):
        self.clips = clips
        print(f"[ENGINE] Syncing {len(clips)} clips from GUI...")
        for i, clip in enumerate(clips):
            print(f"  > Clip {i}: {clip.name} (File: {clip.file_path})")

    def get_frame_at(self, t):
        # Kembalikan frame hitam kosong (1920x1080) agar PreviewPanel tidak error
        # Format: (Height, Width, Channel)
        return np.zeros((1080, 1920, 3), dtype=np.uint8)

==========================================================================================
FILE: gui\main_window.py
==========================================================================================
import sys
from PySide6.QtWidgets import QApplication, QMainWindow, QSplitter
from PySide6.QtCore import Qt

# Import UI Components
from gui.center_panel.preview_panel import PreviewPanel
from gui.left_panel.layer_panel import LayerPanel
from gui.right_panel.setting_panel import SettingPanel
from engine.preview_engine import PreviewEngine 

# Import Controller
from gui.controllers.main_controller import EditorController

try:
    from gui.styles import STYLESHEET
except ImportError:
    STYLESHEET = ""

class VideoEditorApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("MamenPro Editor (Refactored MVC)")
        self.resize(1366, 768)
        
        if STYLESHEET:
            self.setStyleSheet(STYLESHEET)
        
        # 1. Init Components
        self.engine = PreviewEngine()
        self._init_ui()
        
        # 2. Init Controller (Menyerahkan logika ke Controller)
        # Kita passing 'self' agar controller bisa mengakses UI elements
        self.controller = EditorController(self)
        
    def _init_ui(self):
        self.splitter = QSplitter(Qt.Horizontal)
        self.setCentralWidget(self.splitter)
        
        self.preview = PreviewPanel()
        self.layer_panel = LayerPanel()
        self.setting = SettingPanel()
        
        self.splitter.addWidget(self.layer_panel)
        self.splitter.addWidget(self.preview)
        self.splitter.addWidget(self.setting)
        
        self.splitter.setSizes([200, 800, 300])
        self.preview.scene.setSceneRect(0, 0, 1080, 1920) 

# Entry point tetap sama...
if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = VideoEditorApp()
    window.show()
    sys.exit(app.exec())

==========================================================================================
FILE: gui\styles.py
==========================================================================================
import os

# Fungsi untuk memuat file .qss
def load_stylesheet():
    # Mendapatkan lokasi folder tempat file ini berada (gui/)
    base_dir = os.path.dirname(os.path.abspath(__file__))
    file_path = os.path.join(base_dir, "styles.qss")
    
    try:
        with open(file_path, "r") as f:
            return f.read()
    except FileNotFoundError:
        print(f"ERROR: File tema tidak ditemukan di {file_path}")
        return ""

# Variabel ini nanti dipanggil di main.py
STYLESHEET = load_stylesheet()

==========================================================================================
FILE: gui\__init__.py
==========================================================================================


==========================================================================================
FILE: gui\center_panel\preview_panel.py
==========================================================================================
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QComboBox, 
                             QLabel, QGraphicsScene, QPushButton, QSlider, QStyle, QGraphicsRectItem)
from PySide6.QtGui import QBrush, QPen, QColor, QPainter
from PySide6.QtCore import Qt, QTimer, Signal

# Import komponen terkait
from gui.center_panel.video_item import VideoItem
from gui.center_panel.video_view import VideoGraphicsView

class PreviewPanel(QWidget):
    sig_frame_selected = Signal(str)  # Kirim ID ke SettingPanel
    sig_item_moved = Signal(dict)     # Kirim Update Posisi X/Y saat drag

    def __init__(self):
        super().__init__()
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(5, 5, 5, 5)

        self._init_ui()
        
        # Init Ukuran Awal (Delay sedikit agar UI siap)
        QTimer.singleShot(100, lambda: self.change_ratio(self.ratio_cb.currentText()))

    def _init_ui(self):
        # 1. Top Bar (Rasio & Zoom)
        top_bar = QHBoxLayout()
        self.ratio_cb = QComboBox()
        self.ratios = {
            "9:16 (TikTok)": (1080, 1920), 
            "16:9 (YouTube)": (1920, 1080),
            "1:1 (Square)": (1080, 1080), 
            "4:5 (IG Feed)": (1080, 1350)
        }
        self.ratio_cb.addItems(self.ratios.keys())
        self.ratio_cb.currentTextChanged.connect(self.change_ratio)
        
        top_bar.addWidget(QLabel("Ratio:"))
        top_bar.addWidget(self.ratio_cb)
        top_bar.addStretch()
        
        # 2. Area Preview
        self.scene = QGraphicsScene()
        # Set background scene jadi abu-abu gelap (area di luar canvas)
        self.scene.setBackgroundBrush(QBrush(QColor("#1e1e1e")))
        
        self.view = VideoGraphicsView(self.scene)
        self.view.setRenderHint(QPainter.Antialiasing)
        self.view.setRenderHint(QPainter.SmoothPixmapTransform)
        
        # --- INIT GRAPHICS (CANVAS & GUIDE) ---
        self._init_graphics()
        
        # 3. Bottom Bar (Playback Controls)
        control_layout = QHBoxLayout()
        self.btn_play = QPushButton()
        self.btn_play.setIcon(self.style().standardIcon(QStyle.SP_MediaPlay))
        
        self.timeline_slider = QSlider(Qt.Horizontal)
        self.timeline_slider.setRange(0, 1000) # 0 - 100%
        
        control_layout.addWidget(self.btn_play)
        control_layout.addWidget(self.timeline_slider)
        
        # Add to Layout
        self.main_layout.addLayout(top_bar)
        self.main_layout.addWidget(self.view)
        self.main_layout.addLayout(control_layout)

        # Connections
        self.scene.selectionChanged.connect(self._on_selection)
        self.scene.changed.connect(self._on_changed)

    def _init_graphics(self):
        """Membuat area Canvas (Logic) dan Canvas Guide (Visual)"""
        
        # 1. Canvas LOGIC (Invisible Area untuk referensi ukuran & parent item jika perlu)
        # Ditaruh paling belakang (Z = -200)
        self.canvas = QGraphicsRectItem(0, 0, 1080, 1920)
        self.canvas.setBrush(Qt.NoBrush)
        self.canvas.setPen(Qt.NoPen) # Tidak terlihat
        self.canvas.setZValue(-200)  
        self.canvas.setFlag(QGraphicsRectItem.ItemIsMovable, False)
        self.canvas.setFlag(QGraphicsRectItem.ItemIsSelectable, False)
        self.scene.addItem(self.canvas)
        
        # 2. Canvas GUIDE (Garis Putus-putus Visual)
        # Ditaruh paling DEPAN (Z = 9999) agar selalu terlihat di atas video/background
        self.canvas_guide = QGraphicsRectItem(0, 0, 1080, 1920)
        self.canvas_guide.setBrush(Qt.NoBrush)
        
        # Garis Putih Putus-putus
        pen = QPen(QColor(255, 255, 255, 150), 4) # Sedikit lebih tebal
        pen.setStyle(Qt.DashLine)
        self.canvas_guide.setPen(pen)
        
        self.canvas_guide.setZValue(9999) 
        
        # Non-interaktif (Tembus pandang mouse)
        self.canvas_guide.setFlag(QGraphicsRectItem.ItemIsMovable, False)
        self.canvas_guide.setFlag(QGraphicsRectItem.ItemIsSelectable, False)
        self.canvas_guide.setAcceptedMouseButtons(Qt.NoButton) # Klik tembus ke bawah
        
        self.scene.addItem(self.canvas_guide)

    def change_ratio(self, name):
        w, h = self.ratios[name]
        
        # Update Logic & Guide (Safety Check)
        if hasattr(self, 'canvas'):
            self.canvas.setRect(0, 0, w, h)
            
        if hasattr(self, 'canvas_guide'):
            self.canvas_guide.setRect(0, 0, w, h)
            
        self.scene.setSceneRect(0, 0, w, h)
        
        # Reset View agar pas di tengah
        if hasattr(self, 'view'):
            self.view.resetTransform()
            if hasattr(self, 'canvas'):
                self.view.fitInView(self.canvas, Qt.KeepAspectRatio)
            self.view.scale(0.9, 0.9) # Sedikit padding
            if hasattr(self, 'canvas'):
                self.view.centerOn(self.canvas)

    def resizeEvent(self, event):
        super().resizeEvent(event)
        # Pastikan atribut sudah ada sebelum dipanggil (Fix Error AttributeError)
        if hasattr(self, 'ratio_cb') and hasattr(self, 'canvas_guide'):
            self.change_ratio(self.ratio_cb.currentText())

    def select_frame_by_code(self, frame_code):
        self.scene.blockSignals(True)
        self.scene.clearSelection()
        
        found = False
        for item in self.scene.items():
            if hasattr(item, 'name') and item.name == frame_code:
                item.setSelected(True)
                found = True
                break
        
        self.scene.blockSignals(False)
        if found:
            self._on_selection() # Trigger manual update UI

    def _on_selection(self):
        sel = self.scene.selectedItems()
        if sel and isinstance(sel[0], VideoItem):
            self.sig_frame_selected.emit(sel[0].name)

    def _on_changed(self, region):
        # Saat item digeser mouse, kirim sinyal update ke panel kanan
        sel = self.scene.selectedItems()
        if sel and isinstance(sel[0], VideoItem):
            self.sig_item_moved.emit(sel[0].settings)

==========================================================================================
FILE: gui\center_panel\video_item.py
==========================================================================================
import os
from engine.pyav_engine import PyAVClip 
# [PERBAIKAN] Tambahkan QPainterPath di sini
from PySide6.QtGui import QImage, QPixmap, QColor, QBrush, QPen, QFont, QPainter, QTextOption, QPainterPath
from PySide6.QtWidgets import QGraphicsRectItem, QGraphicsItem
from PySide6.QtCore import Qt, QRectF

class VideoItem(QGraphicsRectItem):
    # Tambahkan parameter shape di __init__
    def __init__(self, name, file_path=None, parent=None, shape="portrait"):
        self.name = name 
        self.file_path = file_path
        self.current_pixmap = None 
        self.clip = None          
        self.is_image = False     
        self.duration_s = 0.0
        
        # Tentukan Ukuran Berdasarkan Shape
        if shape == "landscape":
            w, h = 960, 540 # 16:9
        elif shape == "square":
            w, h = 720, 720 # 1:1
        elif shape == "circle":
            w, h = 720, 720 # 1:1 (Akan dicrop lingkaran di paint)
        else: # portrait
            w, h = 540, 960 # 9:16

        # Default Settings
        self.settings = {
            "x": 0, "y": 0, 
            "scale": 100, 
            "rot": 0,
            "opacity": 100,
            "sf_l": 0, "sf_r": 0,
            "frame_w": int(w), 
            "frame_h": int(h),
            "frame_rot": 0,
            "lock": False,
            "shape": shape, # Simpan tipe shape
            "content_type": "media" #default tipe adalah media
        }

        # Init Super Class dengan ukuran w, h
        super().__init__(0, 0, w, h, parent)
        
        self.setFlags(QGraphicsRectItem.ItemIsMovable | 
                      QGraphicsRectItem.ItemIsSelectable | 
                      QGraphicsRectItem.ItemSendsGeometryChanges)
        
        self.setBrush(QBrush(QColor(40, 40, 40, 150))) 
        self.setPen(QPen(QColor("#4cc9f0"), 2))        
        self.setZValue(1)
        self.setTransformOriginPoint(self.rect().center())
        
        if file_path:
            self.set_content(file_path)

    def set_content(self, path):
        self.file_path = path
        if not path: return
        
        self.settings["content_type"] = "media"
        ext = os.path.splitext(path)[1].lower()
        image_exts = ['.jpg', '.jpeg', '.png', '.bmp', '.gif', '.webp']
        
        if ext in image_exts:
            self._load_as_image(path)
        else:
            self._load_as_video(path)

    def set_text_content(self, text, is_paragraph=False):
        """Merender teks menjadi QPixmap"""
        self.file_path = None
        self.clip = None
        
        self.settings["content_type"] = "text"
        self.is_image = True
        self.duration_s = 5.0
        
        base_w, base_h = 1080, 1080
        img = QImage(base_w, base_h, QImage.Format_ARGB32)
        img.fill(Qt.transparent)
        
        painter = QPainter(img)
        painter.setRenderHint(QPainter.Antialiasing)
        painter.setRenderHint(QPainter.TextAntialiasing)
        
        font_size = 80 if not is_paragraph else 50
        font = QFont("Arial", font_size, QFont.Bold if not is_paragraph else QFont.Normal)
        painter.setFont(font)
        painter.setPen(QColor("white"))
        
        rect = QRectF(0, 0, base_w, base_h)
        option = QTextOption()
        if is_paragraph:
            option.setWrapMode(QTextOption.WordWrap)
            option.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        else:
            option.setWrapMode(QTextOption.NoWrap)
            option.setAlignment(Qt.AlignCenter)
            
        painter.drawText(rect, text, option)
        painter.end()
        
        self.current_pixmap = QPixmap.fromImage(img)
        print(f"[VIDEO_ITEM] Text Generated: {text[:20]}...")
        self._apply_auto_fit()

    def _load_as_image(self, path):
        try:
            pix = QPixmap(path)
            if pix.isNull(): raise Exception("Gambar null")
            self.current_pixmap = pix
            self.clip = None
            self.is_image = True
            self.duration_s = 5.0
            print(f"[VIDEO_ITEM] Loaded Image: {path}")
            self._apply_auto_fit()
        except Exception as e:
            print(f"[ERROR] Gagal load gambar: {e}")

    def _load_as_video(self, path):
        try:
            self.clip = PyAVClip(path)
            self.is_image = False
            
            raw_duration = self.clip.container.duration
            if raw_duration:
                self.duration_s = raw_duration / 1000000.0
            else:
                self.duration_s = 0.0 
            
            print(f"[VIDEO_ITEM] Loaded Video: {path} | Dur: {self.duration_s:.2f}s")
            
            self.seek_to(0)
            if self.current_pixmap is None:
                self.seek_to(0.05)

            self._apply_auto_fit()
            
        except Exception as e:
            print(f"[ERROR] Gagal load video via PyAV: {e}")
            self.clip = None

    def _apply_auto_fit(self):
        if self.current_pixmap and not self.current_pixmap.isNull():
            img_w = self.current_pixmap.width()
            img_h = self.current_pixmap.height()
            if img_w == 0 or img_h == 0: return

            frame_w = self.settings.get("frame_w", self.rect().width())
            frame_h = self.settings.get("frame_h", self.rect().height())
            
            scale_w = frame_w / img_w
            scale_h = frame_h / img_h
            fit_scale = min(scale_w, scale_h) * 100 
            
            self.settings["scale"] = int(fit_scale)
            self.settings["rot"] = 0
            self.update()

    def update_from_settings(self, data):
        if "frame_w" in data or "frame_h" in data:
            self.prepareGeometryChange()

        if "x" in data and "y" in data:
            self.setPos(data["x"], data["y"])
        if "frame_rot" in data:
            self.setRotation(data["frame_rot"])
        if "frame_w" in data or "frame_h" in data:
            new_w = data.get("frame_w", self.rect().width())
            new_h = data.get("frame_h", self.rect().height())
            self.setRect(0, 0, new_w, new_h)
            self.setTransformOriginPoint(self.rect().center())
            self.settings["frame_w"] = new_w
            self.settings["frame_h"] = new_h
            
        self.settings.update(data)
        if "lock" in data:
            is_locked = data["lock"]
            self.setFlag(QGraphicsItem.ItemIsMovable, not is_locked)
            self.setPen(QPen(QColor("#ff4d4d") if is_locked else QColor("#4cc9f0"), 2))
        self.update()

    def seek_to(self, time_seconds):
        if self.is_image: return 
        if not self.clip: return
        
        req_time = time_seconds
        if self.duration_s > 0 and req_time >= self.duration_s:
            req_time = max(0, self.duration_s - 0.05)
            
        frame_data = self.clip.get_frame_at(req_time)
        
        if frame_data is not None:
            h, w, ch = frame_data.shape
            try:
                if self.current_pixmap and (self.current_pixmap.width() != w or self.current_pixmap.height() != h):
                    self.prepareGeometryChange()

                q_img = QImage(frame_data.data, w, h, ch * w, QImage.Format_RGB888).copy()
                self.current_pixmap = QPixmap.fromImage(q_img)
                self.update() 
            except Exception as e:
                print(f"[ERROR] Gagal konversi frame ke QImage: {e}")

    def itemChange(self, change, value):
        if change == QGraphicsItem.ItemPositionChange and self.scene():
            new_pos = value
            self.settings["x"] = int(new_pos.x())
            self.settings["y"] = int(new_pos.y())
        return super().itemChange(change, value)
    
    def paint(self, painter, option, widget):
        shape = self.settings.get("shape", "portrait")
        
        painter.save()
        
        # 1. SETUP CLIPPING & SHAPE
        path = QPainterPath()
        if shape == "circle":
            # Jika Bulat, buat path Ellipse
            path.addEllipse(self.rect())
        else:
            # Jika Kotak/Portrait/Landscape, buat path Rect
            path.addRect(self.rect())
            
        # 2. GAMBAR BACKGROUND FRAME (Wadah)
        painter.setPen(self.pen())
        painter.setBrush(self.brush())
        painter.drawPath(path) # Gambar bentuk (Kotak/Bulat)

        # 3. GAMBAR KONTEN (Clip sesuai bentuk)
        if self.current_pixmap and not self.current_pixmap.isNull():
            painter.setClipPath(path) # <--- CLIP PENTING! Agar gambar tidak keluar dari lingkaran
            
            center = self.rect().center()
            painter.translate(center.x(), center.y()) 
            painter.rotate(self.settings["rot"]) 
            scale_factor = self.settings["scale"] / 100.0
            painter.scale(scale_factor, scale_factor)
            painter.setOpacity(self.settings["opacity"] / 100.0)
            
            img_w = self.current_pixmap.width()
            img_h = self.current_pixmap.height()
            painter.drawPixmap(-img_w / 2, -img_h / 2, self.current_pixmap)
            
        painter.restore()

        if self.isSelected():
            self._paint_label(painter)

    def _paint_label(self, painter):
        painter.save()
        label_rect = QRectF(0, -25, self.rect().width(), 25)
        color = QColor("#ff4d4d") if self.settings["lock"] else QColor("#4cc9f0")
        painter.setBrush(color); painter.setPen(Qt.NoPen)
        painter.drawRect(label_rect)
        painter.setPen(Qt.black)
        font = painter.font(); font.setBold(True); painter.setFont(font)
        status = " [LOCKED]" if self.settings["lock"] else ""
        painter.drawText(label_rect, Qt.AlignCenter, f"FRAME {self.name}{status}")
        painter.restore()
    
    def boundingRect(self):
        return QRectF(0, 0, self.settings.get("frame_w", 540), self.settings.get("frame_h", 960))


class BackgroundItem(VideoItem):
    def __init__(self, path, scene_rect):
        super().__init__("BG", path, None)
        self.setZValue(0) 
        
        self.setFlag(QGraphicsItem.ItemIsMovable, False)
        self.setFlag(QGraphicsItem.ItemIsSelectable, False)
        self.setFlag(QGraphicsItem.ItemSendsGeometryChanges, False)
        self.setAcceptedMouseButtons(Qt.NoButton)
        
        self.settings = {
            "x": 0, "y": 0, "scale": 100, "opacity": 100, "rot": 0
        }
        self.set_content(path)

    def update_bg_settings(self, new_data):
        self.prepareGeometryChange()
        self.settings.update(new_data)
        self.update()

    def paint(self, painter, option, widget):
        if self.current_pixmap and not self.current_pixmap.isNull():
            painter.save()
            painter.translate(self.settings["x"], self.settings["y"])
            scale = self.settings["scale"] / 100.0
            painter.scale(scale, scale)
            painter.setOpacity(self.settings["opacity"] / 100.0)
            painter.drawPixmap(0, 0, self.current_pixmap)
            painter.restore()
        else:
            painter.setBrush(QColor(255, 0, 0, 50))
            painter.setPen(Qt.NoPen)
            painter.drawRect(self.boundingRect())
    
    def boundingRect(self):
        if self.current_pixmap:
            w = self.current_pixmap.width() * (self.settings["scale"] / 100.0)
            h = self.current_pixmap.height() * (self.settings["scale"] / 100.0)
            return QRectF(self.settings["x"], self.settings["y"], w, h)
        return QRectF(0, 0, 1080, 1920)

==========================================================================================
FILE: gui\center_panel\video_view.py
==========================================================================================
from PySide6.QtWidgets import QGraphicsView, QFrame, QGraphicsRectItem, QGraphicsPathItem
from PySide6.QtGui import QPainter, QMouseEvent, QWheelEvent, QBrush, QColor, QPen, QPainterPath
from PySide6.QtCore import Qt

# Import hanya untuk pengecekan tipe (agar View tau mana yang VideoItem)
from gui.center_panel.video_item import VideoItem 

class CanvasContainer(QGraphicsRectItem):
    def __init__(self, w, h):
        super().__init__(0, 0, w, h)
        self.setBrush(QBrush(QColor("#1e1e1e")))
        self.setPen(QPen(QColor("#333333"), 1))
        self.setZValue(0)

class DimmingOverlay(QGraphicsPathItem):
    def __init__(self, canvas_rect):
        super().__init__()
        self.setBrush(QBrush(QColor(0, 0, 0, 180)))
        self.setPen(Qt.NoPen)
        self.setZValue(10)
        self.setAcceptedMouseButtons(Qt.NoButton)
        self.update_mask(canvas_rect)

    def update_mask(self, canvas_rect):
        path = QPainterPath()
        path.addRect(-50000, -50000, 100000, 100000) # Area infinite gelap
        path.addRect(canvas_rect) # Area terang (lubang)
        self.setPath(path)

class VideoGraphicsView(QGraphicsView):
    def __init__(self, scene):
        super().__init__(scene)
        self.setRenderHint(QPainter.Antialiasing)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
        self.setAlignment(Qt.AlignCenter)
        self.setBackgroundBrush(QBrush(QColor("#0a0a0a")))
        self.setFrameShape(QFrame.NoFrame)
        self.setViewportUpdateMode(QGraphicsView.FullViewportUpdate) 

    def wheelEvent(self, event: QWheelEvent):
        # Zoom Logic
        factor = 1.15 if event.angleDelta().y() > 0 else 1 / 1.15
        self.scale(factor, factor)

    def mousePressEvent(self, event: QMouseEvent):
        # Pan Logic (Spasi/Ctrl + Click)
        if event.button() == Qt.LeftButton and event.modifiers() == Qt.ControlModifier:
            self.setDragMode(QGraphicsView.ScrollHandDrag)
            # Fake event agar View langsung merespon drag
            fake = QMouseEvent(event.type(), event.position(), Qt.LeftButton, Qt.LeftButton, Qt.NoModifier)
            super().mousePressEvent(fake)
            return

        # Selection Logic
        if event.button() == Qt.LeftButton:
            pos = self.mapToScene(event.position().toPoint())
            item = self.scene().itemAt(pos, self.transform())
            
            # Jika klik VideoItem -> Mode Select biasa
            if isinstance(item, VideoItem): 
                self.setDragMode(QGraphicsView.NoDrag)
            # Jika klik background -> Mode RubberBand (kotak seleksi biru)
            else:
                self.setDragMode(QGraphicsView.RubberBandDrag)
                
        super().mousePressEvent(event)

    def mouseReleaseEvent(self, event: QMouseEvent):
        super().mouseReleaseEvent(event)
        self.setDragMode(QGraphicsView.NoDrag)

==========================================================================================
FILE: gui\center_panel\__init__.py
==========================================================================================


==========================================================================================
FILE: gui\controllers\main_controller.py
==========================================================================================
import os
# Pastikan baris ini lengkap:
from PySide6.QtWidgets import QInputDialog, QStyle, QFileDialog, QMessageBox
from PySide6.QtCore import Qt

from manager.media_manager import MediaManager
from gui.center_panel.video_item import VideoItem, BackgroundItem
from engine.caption.caption_flow import apply_caption
from gui.utils.bg_service import BackgroundService
from engine.render_engine import RenderWorker  # Pastikan worker juga sudah diimport

class EditorController:
    def __init__(self, main_window):
        self.view = main_window
        self.preview = main_window.preview
        self.layer_panel = main_window.layer_panel
        self.setting = main_window.setting
        self.engine = main_window.engine
        
        # State
        self.bg_item = None

        # Inisialisasi Koneksi
        self._connect_signals()

    def _connect_signals(self):
        # 1. Layer & Selection Sync
        self.layer_panel.sig_layer_selected.connect(self.preview.select_frame_by_code)
        self.layer_panel.sig_layer_selected.connect(self.on_canvas_selection_update_ui)
        self.preview.sig_frame_selected.connect(self.layer_panel.select_layer_by_code)
        self.layer_panel.sig_layer_created.connect(self.on_create_visual_item)
        
        self.layer_panel.sig_layer_reordered.connect(self.on_layer_reordered)
        self.layer_panel.sig_delete_layer.connect(self.on_layer_deleted)

        # 2. Settings & Transform
        self.setting.on_setting_change.connect(self.on_setting_changed)
        self.preview.scene.selectionChanged.connect(self.on_canvas_selection_update_ui)
        self.preview.sig_item_moved.connect(self.on_canvas_item_moved)

        # 3. Action Buttons (Layer Panel)
        self.layer_panel.btn_add_bg.clicked.connect(self.on_add_bg_clicked)
        self.layer_panel.sig_bg_changed.connect(self.on_bg_properties_changed)
        self.layer_panel.btn_add_content.clicked.connect(self.on_add_content_clicked)
        self.layer_panel.sig_bg_toggle.connect(self.on_bg_toggle_changed)
        self.layer_panel.btn_add_text.clicked.connect(self.on_add_text_clicked)
        self.layer_panel.btn_add_paragraph.clicked.connect(self.on_add_paragraph_clicked)
        self.layer_panel.btn_add_audio.clicked.connect(self.on_add_audio_clicked)
        
        # 4. Engine & Timeline
        self.preview.timeline_slider.valueChanged.connect(self.on_slider_moved)
        self.preview.btn_play.clicked.connect(self.engine.toggle_play)
        self.engine.sig_time_changed.connect(self.update_ui_from_engine)
        self.engine.sig_state_changed.connect(self.update_play_button_icon)
        
        # 5. Caption
        self.setting.caption_tab.sig_generate_caption.connect(self.on_generate_caption)
        self.layer_panel.render_tab.btn_render.clicked.connect(lambda: print("üöÄ Rendering dimulai..."))


        self.layer_panel.render_tab.btn_render.clicked.connect(self.on_render_clicked)
    # --- LOGIC HANDLERS ---

    def on_render_clicked(self):
        # 1. Tentukan lokasi simpan
        output_path, _ = QFileDialog.getSaveFileName(
            self.view, "Simpan Video", "project_output.mp4", "Video Files (*.mp4)"
        )
        if not output_path:
            return

        # 2. Kumpulkan Data dari Canvas (Scene Items)
        items_data = []
        scene_items = self.preview.scene.items()
        
        # Total durasi proyek (dari engine slider range)
        total_duration = self.engine.duration
        
        for item in scene_items:
            # Kita hanya render VideoItem dan BackgroundItem
            if hasattr(item, 'file_path') and item.file_path:
                # Perhitungan geometri visual vs file asli
                # FFmpeg butuh data pixel absolut (int), bukan float
                
                # Logic sederhana: Ambil bounding rect item di scene
                pos = item.scenePos()
                rect = item.boundingRect() # Ukuran asli item (sebelum scale transform)
                
                # Mendapatkan Scale factor dari transformasi
                # Di Qt, scale ada di transform matrix atau property scale()
                # Karena kita simpan di item.settings, kita ambil dari sana agar akurat
                scale_percent = item.settings.get('scale', 100)
                scale_factor = scale_percent / 100.0
                
                final_w = int(rect.width() * scale_factor)
                final_h = int(rect.height() * scale_factor)
                
                item_data = {
                    'path': item.file_path,
                    'x': int(pos.x()),
                    'y': int(pos.y()),
                    'w': final_w,
                    'h': final_h,
                    'z_value': item.zValue(), # Untuk urutan tumpukan
                    # Asumsi sederhana timeline (item muncul dari detik 0 sampai durasi video itu habis)
                    # Nanti ini perlu diupdate jika ada fitur trimming di timeline
                    'start_time': 0, 
                    'end_time': item.duration_s if hasattr(item, 'duration_s') else total_duration
                }
                items_data.append(item_data)

        if not items_data:
            QMessageBox.warning(self.view, "Render", "Canvas kosong, tidak ada yang dirender!")
            return

        # 3. Jalankan Worker di Thread Terpisah
        self.worker = RenderWorker(items_data, output_path, total_duration)
        self.worker.sig_progress.connect(self.on_render_progress)
        self.worker.sig_finished.connect(self.on_render_finished)
        
        # Disable tombol render agar tidak dipencet 2x
        self.layer_panel.render_tab.btn_render.setEnabled(False)
        self.layer_panel.render_tab.btn_render.setText("Rendering...")
        
        self.worker.start()
        
    def on_render_progress(self, msg):
        print(f"[RENDER] {msg}")
        # Jika Anda punya status bar, update di sini:
        # self.view.statusBar().showMessage(msg)

    def on_render_finished(self, success, msg):
        self.layer_panel.render_tab.btn_render.setEnabled(True)
        self.layer_panel.render_tab.btn_render.setText("Render Video")
        
        if success:
            QMessageBox.information(self.view, "Sukses", msg)
        else:
            QMessageBox.critical(self.view, "Gagal", f"Terjadi kesalahan:\n{msg}")
            
    def recalculate_global_duration(self):
        max_duration = 0.0
        has_clips = False
        for item in self.preview.scene.items():
            if isinstance(item, VideoItem):
                if item.duration_s > max_duration:
                    max_duration = item.duration_s
                has_clips = True
        
        if max_duration == 0 and not has_clips:
            max_duration = 5.0
        
        self.engine.set_duration(max_duration)
        self.preview.timeline_slider.setRange(0, int(max_duration * 100))

    def on_create_visual_item(self, frame_code, shape="portrait"):
        item = VideoItem(frame_code, None, None, shape=shape)
        self.preview.scene.addItem(item)
        item.setPos(50, 50)
        item.settings.update({'x': 50, 'y': 50})
        
        self.preview.scene.clearSelection()
        item.setSelected(True)
        self.setting.set_values(item.settings)
        self.recalculate_global_duration()
        print(f"[CTRL] Created Frame {frame_code}")

    def on_add_bg_clicked(self):
        if not self.layer_panel.chk_bg_toggle.isChecked(): return
        
        data = MediaManager.open_media_dialog(self.view, "Pilih Background Video/Image")
        if not data: return
        
        path = data['path']
        self.layer_panel.btn_add_bg.setText(f"BG: {data['name']}")
        self.engine.bg_layer.set_source(path)
        
        if self.bg_item: 
            self.preview.scene.removeItem(self.bg_item)
            
        self.bg_item = BackgroundItem(path, self.preview.scene.sceneRect())
        self.bg_item.seek_to(0)
        
        # Gunakan Service untuk hitung matematika scaling
        geo_settings = BackgroundService.calculate_bg_geometry(
            self.bg_item.current_pixmap, 
            self.preview.scene.sceneRect()
        )
        
        if geo_settings:
            self.bg_item.update_bg_settings(geo_settings)
            self.layer_panel.set_bg_values(self.bg_item.settings)
            self.layer_panel.show_bg_controls(True)
        
        self.preview.scene.addItem(self.bg_item)
        self.preview.scene.update()
        self.recalculate_global_duration()

    def on_bg_properties_changed(self, data):
        if self.bg_item:
            self.bg_item.update_bg_settings(data)
        self.engine.bg_layer.update_state(data)
        self.preview.scene.update()

    def on_bg_toggle_changed(self, is_on):
        if self.bg_item:
            self.bg_item.setVisible(is_on)
        self.engine.bg_layer.set_enabled(is_on)

    def on_add_content_clicked(self):
        selected = self.preview.scene.selectedItems()
        if not selected or not isinstance(selected[0], VideoItem): return

        target_item = selected[0]
        data = MediaManager.open_media_dialog(self.view)
        if not data: return

        target_item.set_content(data['path'])
        self.setting.set_values(target_item.settings)
        self.recalculate_global_duration()
        target_item.update()
        self.preview.scene.update()

    def on_add_text_clicked(self):
        self._handle_text_input("Input Teks", "Masukkan Judul:", is_paragraph=False)

    def on_add_paragraph_clicked(self):
        self._handle_text_input("Input Paragraf", "Masukkan Paragraf:", is_paragraph=True)

    def _handle_text_input(self, title, label, is_paragraph):
        selected = self.preview.scene.selectedItems()
        if not selected or not isinstance(selected[0], VideoItem): return
        
        target_item = selected[0]
        if is_paragraph:
            text, ok = QInputDialog.getMultiLineText(self.view, title, label)
        else:
            text, ok = QInputDialog.getText(self.view, title, label)
            
        if ok and text:
            target_item.set_text_content(text, is_paragraph=is_paragraph)
            self.setting.set_values(target_item.settings)
            self.recalculate_global_duration()
            self.preview.scene.update()

    def on_add_audio_clicked(self):
        data = MediaManager.open_audio_dialog(self.view)
        if data:
            self.layer_panel.btn_add_audio.setText(data['name'])

    def on_setting_changed(self, data):
        selected = self.preview.scene.selectedItems()
        if selected and isinstance(selected[0], VideoItem):
            item = selected[0]
            item.update_from_settings(data)
            
            # Sync internal settings
            item.settings.update({
                "x": int(item.pos().x()),
                "y": int(item.pos().y()),
                "scale": data["scale"],
                "rot": data["rotation"],
                "opacity": data["opacity"],
                "frame_rot": data["frame_rot"],
                "lock": data["lock"]
            })
            
            is_unlocked = not data["lock"]
            self.layer_panel.set_delete_enabled(is_unlocked)
            self.layer_panel.set_reorder_enabled(is_unlocked)

    def on_canvas_selection_update_ui(self):
        selected = self.preview.scene.selectedItems()
        is_video_item = False
        
        if selected and isinstance(selected[0], VideoItem):
            is_video_item = True
            item = selected[0]
            self.setting.set_values(item.settings)
            
            content_type = item.settings.get("content_type", "media")
            self.setting.set_active_tab_by_type(content_type)
            
            is_locked = item.settings.get("lock", False)
            self.layer_panel.set_delete_enabled(not is_locked)
            self.layer_panel.set_reorder_enabled(not is_locked)
        else:
            self.layer_panel.set_delete_enabled(False)
            self.layer_panel.set_reorder_enabled(False)
        
        # Handle button state safely
        if hasattr(self.layer_panel, 'set_content_button_enabled'):
            self.layer_panel.set_content_button_enabled(is_video_item)
        else:
            self.layer_panel.btn_add_content.setEnabled(is_video_item)

    def on_canvas_item_moved(self, settings_data):
        self.setting.set_values(settings_data)

    def on_layer_reordered(self):
        list_widget = self.layer_panel.list_layers
        count = list_widget.count()
        for i in range(count):
            item_list = list_widget.item(i)
            frame_name = item_list.text().replace("FRAME ", "")
            for graphics_item in self.preview.scene.items():
                if hasattr(graphics_item, 'name') and graphics_item.name == frame_name:
                    graphics_item.setZValue(count - i) 
                    break
        self.preview.scene.update()

    def on_layer_deleted(self, frame_code):
        scene = self.preview.scene
        for item in scene.items():
            if hasattr(item, 'name') and item.name == frame_code:
                scene.removeItem(item)
                break
        scene.update()
        self.recalculate_global_duration()
        self.setting.blockSignals(True) # Hindari loop signal
        self.setting.blockSignals(False)

    def on_slider_moved(self, value):
        time_s = value / 100.0
        if not self.engine.timer.isActive():
            self.engine.set_time(time_s)

    def update_ui_from_engine(self, t):
        self.preview.timeline_slider.blockSignals(True)
        self.preview.timeline_slider.setValue(int(t * 100))
        self.preview.timeline_slider.blockSignals(False)
        
        for item in self.preview.scene.items():
            if isinstance(item, VideoItem):
                item.seek_to(t)
            if self.bg_item:
                self.bg_item.seek_to(t)

    def update_play_button_icon(self, is_playing):
        icon = QStyle.SP_MediaPause if is_playing else QStyle.SP_MediaPlay
        self.preview.btn_play.setIcon(self.view.style().standardIcon(icon))

    def on_generate_caption(self, data):
        # Mencari video aktif
        video_path = None
        for item in self.preview.scene.items():
            if isinstance(item, VideoItem):
                video_path = item.file_path
                break
                
        if not video_path:
            print("‚ùå Tidak ada video aktif untuk caption")
            return

        base, ext = os.path.splitext(video_path)
        output = base + "_captioned.mp4"
        preset_map = {
            "Karaoke Highlight (Word-by-word)": "karaoke",
            "Custom (Manual)": "chunk",
            "Netflix Standard": "chunk",
            "Youtube Shorts (Yellow Bold)": "karaoke",
            "Cinematic Minimal": "chunk"
        }
        preset = preset_map.get(data["preset"], "karaoke")
        
        print("üé§ Generating caption...")
        apply_caption(video_path=video_path, output_path=output, preset=preset)
        print(f"‚úÖ Caption selesai: {output}")

==========================================================================================
FILE: gui\left_panel\audio_tab.py
==========================================================================================
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QListWidget, QListWidgetItem, 
                             QLabel, QPushButton, QTabWidget, QFrame)
from PySide6.QtCore import Qt, QSize

class AudioTab(QWidget):
    def __init__(self):
        super().__init__()
        # Layout utama tanpa margin agar pas di tab
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)
        
        # Menggunakan Tab Internal untuk memisah Musik & SFX
        self.inner_tabs = QTabWidget()
        self.layout.addWidget(self.inner_tabs)
        
        # Tab 1: Music Library
        self.music_list = AudioListWidget("music")
        self.inner_tabs.addTab(self.music_list, "Music")
        
        # Tab 2: Sound Effects (SFX)
        self.sfx_list = AudioListWidget("sfx")
        self.inner_tabs.addTab(self.sfx_list, "SFX")

class AudioListWidget(QWidget):
    def __init__(self, category):
        super().__init__()
        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 10, 5, 5)
        
        # Header: Label & Tombol Import
        header_layout = QHBoxLayout()
        lbl_title = QLabel(f"LIBRARY {category.upper()}")
        lbl_title.setStyleSheet("font-weight: bold; color: #fe8019;")
        
        self.btn_import = QPushButton("Import File")
        self.btn_import.setFixedHeight(25)
        self.btn_import.setStyleSheet("""
            QPushButton { background-color: #3a0ca3; color: white; border: none; padding: 0 10px; border-radius: 4px; }
            QPushButton:hover { background-color: #4361ee; }
        """)
        
        header_layout.addWidget(lbl_title)
        header_layout.addStretch()
        header_layout.addWidget(self.btn_import)
        layout.addLayout(header_layout)
        
        # List Widget untuk menampung item
        self.list_widget = QListWidget()
        self.list_widget.setStyleSheet("""
            QListWidget { background-color: #1d2021; border: 1px solid #504945; border-radius: 4px; }
            QListWidget::item { border-bottom: 1px solid #3c3836; }
            QListWidget::item:selected { background-color: #3c3836; border: none; }
        """)
        layout.addWidget(self.list_widget)
        
        # --- ISI DUMMY DATA ---
        if category == "music":
            self._add_item("Cinematic Epic", "02:30", "#b16286")
            self._add_item("Happy Vibes", "01:45", "#d79921")
            self._add_item("Lo-Fi Study", "03:10", "#458588")
            self._add_item("Rock Energetic", "02:15", "#cc241d")
            self._add_item("Acoustic Morning", "02:50", "#98971a")
        else:
            self._add_item("Whoosh Transition", "00:02", "#689d6a")
            self._add_item("Mouse Click", "00:01", "#98971a")
            self._add_item("Explosion Big", "00:05", "#d65d0e")
            self._add_item("Typing Keyboard", "00:03", "#a89984")
            self._add_item("Camera Shutter", "00:01", "#458588")

    def _add_item(self, name, duration, color_code):
        # 1. Buat QListWidgetItem sebagai wadah
        item = QListWidgetItem(self.list_widget)
        item.setSizeHint(QSize(0, 50)) # Tinggi baris item
        
        # 2. Buat Widget Custom untuk tampilan baris
        widget = QFrame()
        w_layout = QHBoxLayout(widget)
        w_layout.setContentsMargins(5, 5, 5, 5)
        w_layout.setSpacing(10)
        
        # Icon Bulat Warna (Visualisasi Cover Art)
        lbl_icon = QLabel()
        lbl_icon.setFixedSize(32, 32)
        lbl_icon.setStyleSheet(f"background-color: {color_code}; border-radius: 16px; border: 2px solid #504945;")
        
        # Info Text (Judul & Durasi)
        info_layout = QVBoxLayout()
        info_layout.setSpacing(0)
        info_layout.setContentsMargins(0, 2, 0, 2)
        
        lbl_name = QLabel(name)
        lbl_name.setStyleSheet("font-weight: bold; color: #ebdbb2; font-size: 11px;")
        
        lbl_dur = QLabel(duration)
        lbl_dur.setStyleSheet("color: #a89984; font-size: 10px;")
        
        info_layout.addWidget(lbl_name)
        info_layout.addWidget(lbl_dur)
        info_layout.addStretch()
        
        # Tombol Aksi (Play & Add)
        btn_play = QPushButton("‚ñ∂")
        btn_play.setFixedSize(26, 26)
        btn_play.setToolTip("Preview Audio")
        btn_play.setStyleSheet("""
            QPushButton { background-color: #3c3836; color: #ebdbb2; border: 1px solid #504945; border-radius: 13px; }
            QPushButton:hover { background-color: #ebdbb2; color: #282828; }
        """)
        
        btn_add = QPushButton("+")
        btn_add.setFixedSize(26, 26)
        btn_add.setToolTip("Tambahkan ke Timeline")
        btn_add.setStyleSheet("""
            QPushButton { background-color: #3c3836; color: #b8bb26; border: 1px solid #504945; border-radius: 13px; font-weight: bold; }
            QPushButton:hover { background-color: #b8bb26; color: #282828; border-color: #b8bb26; }
        """)
        btn_add.clicked.connect(lambda: print(f"Menambahkan audio: {name}"))
        
        # Masukkan ke layout
        w_layout.addWidget(lbl_icon)
        w_layout.addLayout(info_layout)
        w_layout.addStretch()
        w_layout.addWidget(btn_play)
        w_layout.addWidget(btn_add)
        
        # 3. Set Widget ke Item
        self.list_widget.setItemWidget(item, widget)

==========================================================================================
FILE: gui\left_panel\layer_panel.py
==========================================================================================
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QGroupBox, 
                             QGridLayout, QLabel, QPushButton, QCheckBox, 
                             QSpinBox, QListWidget, QFrame, QScrollArea, QComboBox, QTabWidget, QListWidgetItem, QMenu)
from PySide6.QtCore import Qt, Signal

# Import Panel-Panel Tab
from gui.left_panel.template_tab import TemplateTab
from gui.left_panel.presetchroma_panel import PresetChromaPanel
from gui.left_panel.audio_tab import AudioTab
from gui.left_panel.render_tab import RenderTab

class LayerPanel(QWidget):
    # Sinyal untuk komunikasi ke Main/Preview
    sig_layer_created = Signal(str, str)      
    
    sig_layer_selected = Signal(str)     
    sig_layer_reordered = Signal(int, int) 
    sig_delete_layer = Signal(str)       
    sig_bg_changed = Signal(dict)          
    sig_bg_toggle = Signal(bool)

    def __init__(self):
        super().__init__()
        self.setFixedWidth(320)
        
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(0, 0, 0, 0)
        
        # --- SISTEM TAB ---
        self.tabs = QTabWidget()
        self.main_layout.addWidget(self.tabs)
        
        # 1. Tab Editor
        self.tab_editor = QWidget()
        self._init_editor_ui()
        
        # ... (Tab lain tetap sama) ...
        self.tab_templates = TemplateTab()
        self.tab_chroma = PresetChromaPanel()
        self.tab_audio = AudioTab()
        
        self.tabs.addTab(self.tab_editor, "Editor")
        self.tabs.addTab(self.tab_templates, "Templates")
        self.tabs.addTab(self.tab_chroma, "Chroma")
        self.tabs.addTab(self.tab_audio, "Audio")

        self._connect_internal_signals()

    def _init_editor_ui(self):
        """Membangun UI untuk Tab Editor"""
        layout = QVBoxLayout(self.tab_editor)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(10)
        
        # ==========================================
        # 1. ATAS: AUDIO & BACKGROUND
        # ==========================================
        top_group_container = QWidget()
        top_group_layout = QVBoxLayout(top_group_container)
        top_group_layout.setContentsMargins(0, 0, 0, 0)

        # --- Grup Audio Settings ---
        self.group_audio = QGroupBox("AUDIO SETTINGS")
        audio_grid = QGridLayout(self.group_audio)
        self.btn_add_audio = QPushButton("Add Music")
        self.chk_mute = QCheckBox("Mute")
        self.spn_volume = QSpinBox(); self.spn_volume.setRange(0, 100); self.spn_volume.setValue(100)
        
        audio_grid.addWidget(self.btn_add_audio, 0, 0, 1, 2)
        audio_grid.addWidget(QLabel("Vol:"), 1, 0); audio_grid.addWidget(self.spn_volume, 1, 1)
        audio_grid.addWidget(self.chk_mute, 1, 2)
        top_group_layout.addWidget(self.group_audio)

        # --- Grup Background Settings ---
        self.group_bg = QGroupBox("BACKGROUND SETTING")
        self.group_bg.setStyleSheet("QGroupBox { font-weight: bold; border: 1px solid #636e72; margin-top: 5px; }")
        
        bg_main_layout = QVBoxLayout(self.group_bg)
        bg_main_layout.setSpacing(5)
        
        # BARIS 1: Tombol + Toggle
        row1_layout = QHBoxLayout()
        self.btn_add_bg = QPushButton("Add Background")
        self.btn_add_bg.setStyleSheet("background-color: #2d3436; color: white;")
        
        self.chk_bg_toggle = QCheckBox("ON")
        self.chk_bg_toggle.setChecked(True)
        self.chk_bg_toggle.setStyleSheet("font-weight: bold;")
        self.chk_bg_toggle.toggled.connect(self._on_bg_toggled_internal)
        
        row1_layout.addWidget(self.btn_add_bg, stretch=4)
        row1_layout.addWidget(self.chk_bg_toggle, stretch=1)
        bg_main_layout.addLayout(row1_layout)

        # BARIS 2: Grid 3 Kolom Rapat
        bg_grid = QGridLayout()
        bg_grid.setSpacing(5)
        bg_grid.setContentsMargins(0, 0, 0, 0)

        # Init Input
        self.spin_bg_x = self._create_spinbox("Posisi X", -2000, 2000, 0)
        self.spin_bg_y = self._create_spinbox("Posisi Y", -2000, 2000, 0)
        self.spin_bg_scale = self._create_spinbox("Zoom (Scale)", 1, 1000, 100)
        self.spn_vignette = self._create_spinbox("Efek Vignette", 0, 100, 0)
        self.spn_blur = self._create_spinbox("Efek Blur", 0, 100, 0)

        def add_cell(row, col, label_text, widget):
            container = QWidget()
            h_layout = QHBoxLayout(container)
            h_layout.setContentsMargins(0, 0, 0, 0)
            h_layout.setSpacing(2)
            lbl = QLabel(label_text)
            lbl.setStyleSheet("color: #b2bec3; font-size: 10px;")
            lbl.setFixedWidth(25)
            h_layout.addWidget(lbl); h_layout.addWidget(widget)
            bg_grid.addWidget(container, row, col)

        add_cell(0, 0, "X:", self.spin_bg_x)
        add_cell(0, 1, "Y:", self.spin_bg_y)
        add_cell(0, 2, "Zm:", self.spin_bg_scale)
        add_cell(1, 0, "Vig:", self.spn_vignette)
        add_cell(1, 1, "Blr:", self.spn_blur)
        bg_grid.addWidget(QLabel(""), 1, 2) # Empty cell

        bg_main_layout.addLayout(bg_grid)
        top_group_layout.addWidget(self.group_bg)

        layout.addWidget(top_group_container)

        # ==========================================
        # 2. TENGAH: TIMELINE LAYERS
        # ==========================================
        self.mid_container = QGroupBox("TIMELINE LAYERS")
        mid_layout = QVBoxLayout(self.mid_container)

        self.list_layers = QListWidget()
        mid_layout.addWidget(self.list_layers)

        layer_btns = QHBoxLayout()
                
        # [MODIFIKASI] Tombol NEW dengan Menu Dropdown
        self.btn_new = QPushButton("+ New Frame")
        self.btn_new.setStyleSheet("background-color: #0984e3; color: white; font-weight: bold; padding: 5px;")
        
        # Buat Menu Dropdown
        self.menu_new = QMenu(self)
        self.menu_new.setStyleSheet("QMenu { background-color: #2d3436; color: white; } QMenu::item:selected { background-color: #0984e3; }")
        
        # Tambahkan Aksi
        self.menu_new.addAction("Portrait (9:16)", lambda: self.action_add_new("portrait"))
        self.menu_new.addAction("Landscape (16:9)", lambda: self.action_add_new("landscape"))
        self.menu_new.addAction("Kotak / Square (1:1)", lambda: self.action_add_new("square"))
        self.menu_new.addAction("Bulat / Circle", lambda: self.action_add_new("circle"))
        
        # Pasang Menu ke Tombol
        self.btn_new.setMenu(self.menu_new)
        
        
        self.btn_del = QPushButton("Del") 
        self.btn_up = QPushButton("‚ñ≤"); self.btn_up.setFixedWidth(30)
        self.btn_down = QPushButton("‚ñº"); self.btn_down.setFixedWidth(30)

        layer_btns.addWidget(self.btn_new, stretch=1)
        layer_btns.addWidget(self.btn_del)
        layer_btns.addStretch()
        layer_btns.addWidget(self.btn_up)
        layer_btns.addWidget(self.btn_down)
        mid_layout.addLayout(layer_btns)

        layout.addWidget(self.mid_container, stretch=1)

        # ==========================================
        # 3. BAWAH: TOMBOL ADD CONTENT (MODIFIKASI)
        # ==========================================
        # Layout Horizontal 3 Tombol
        content_btn_layout = QHBoxLayout()
        content_btn_layout.setSpacing(2)

        # 1. Tombol Add Video/Image (60%)
        self.btn_add_content = QPushButton("+ Video/Img")
        self.btn_add_content.setFixedHeight(35)
        # Warna default (Disabled style, akan diubah oleh set_content_button_enabled)
        self.btn_add_content.setStyleSheet("background-color: #504945; color: #a89984; font-weight: bold;")
        self.btn_add_content.setEnabled(False) 
        
        # 2. Tombol Add Teks (20%)
        self.btn_add_text = QPushButton("+ Teks")
        self.btn_add_text.setFixedHeight(35)
        self.btn_add_text.setStyleSheet("background-color: #504945; color: #a89984; font-weight: bold;")
        self.btn_add_text.setEnabled(False)
        
        # 3. Tombol Add Paragraf (20%)
        self.btn_add_paragraph = QPushButton("+ Para")
        self.btn_add_paragraph.setFixedHeight(35)
        self.btn_add_paragraph.setStyleSheet("background-color: #504945; color: #a89984; font-weight: bold;")
        self.btn_add_paragraph.setEnabled(False)

        # Masukkan ke layout dengan Stretch Factor (6 : 2 : 2)
        content_btn_layout.addWidget(self.btn_add_content, stretch=6)
        content_btn_layout.addWidget(self.btn_add_text, stretch=2)
        content_btn_layout.addWidget(self.btn_add_paragraph, stretch=2)

        layout.addLayout(content_btn_layout)

        # ==========================================
        # 4. EXTRA & RENDER
        # ==========================================
        self.render_tab = RenderTab()
        layout.addWidget(self.render_tab)

        # Koneksi Signal Input Background
        self.spin_bg_x.valueChanged.connect(self._emit_bg_change)
        self.spin_bg_y.valueChanged.connect(self._emit_bg_change)
        self.spin_bg_scale.valueChanged.connect(self._emit_bg_change)
    
    # ... (Method _create_spinbox, _emit_bg_change, _on_bg_toggled_internal dll tetap sama) ...

    def _create_spinbox(self, tooltip, min_v, max_v, default=0):
        sb = QSpinBox()
        sb.setRange(min_v, max_v)
        sb.setValue(default)
        sb.setToolTip(tooltip)
        sb.setButtonSymbols(QSpinBox.NoButtons) 
        sb.setStyleSheet("background-color: #444; color: white; padding: 2px;")
        return sb

    def _emit_bg_change(self):
        data = {
            "x": self.spin_bg_x.value(),
            "y": self.spin_bg_y.value(),
            "scale": self.spin_bg_scale.value(),
            "blur": self.spn_blur.value(),
            "vig": self.spn_vignette.value()
        }
        self.sig_bg_changed.emit(data)

    def _on_bg_toggled_internal(self, checked):
        self.btn_add_bg.setEnabled(checked)
        self.btn_add_bg.setStyleSheet("background-color: #2d3436; color: white;" if checked else "background-color: #636e72; color: #b2bec3;")
        self.spin_bg_x.setEnabled(checked)
        self.spin_bg_y.setEnabled(checked)
        self.spin_bg_scale.setEnabled(checked)
        self.spn_vignette.setEnabled(checked)
        self.spn_blur.setEnabled(checked)
        self.chk_bg_toggle.setText("ON" if checked else "OFF")
        self.sig_bg_toggle.emit(checked)
        
    def show_bg_controls(self, visible=True):
        is_on = self.chk_bg_toggle.isChecked()
        should_enable = visible and is_on
        self.spin_bg_x.setEnabled(should_enable)
        self.spin_bg_y.setEnabled(should_enable)
        self.spin_bg_scale.setEnabled(should_enable)
            
    def set_bg_values(self, data):
        self.blockSignals(True)
        self.spin_bg_x.setValue(data.get("x", 0))
        self.spin_bg_y.setValue(data.get("y", 0))
        self.spin_bg_scale.setValue(data.get("scale", 100))
        self.spn_blur.setValue(data.get("blur", 0))
        self.spn_vignette.setValue(data.get("vig", 0))
        self.blockSignals(False)
  
    # [MODIFIKASI] Method untuk mengaktifkan/mematikan 3 tombol sekaligus
    def set_content_button_enabled(self, enabled):
        # 1. Tombol Video/Image
        self.btn_add_content.setEnabled(enabled)
        
        # 2. Tombol Teks
        self.btn_add_text.setEnabled(enabled)
        
        # 3. Tombol Paragraph
        self.btn_add_paragraph.setEnabled(enabled)

        if enabled:
            # Warna Aktif
            self.btn_add_content.setStyleSheet("background-color: #3a0ca3; color: white; font-weight: bold;")
            self.btn_add_text.setStyleSheet("background-color: #00b894; color: white; font-weight: bold;") # Hijau Teal
            self.btn_add_paragraph.setStyleSheet("background-color: #0984e3; color: white; font-weight: bold;") # Biru Terang
            
            self.btn_add_content.setToolTip("Import Video/Gambar")
            self.btn_add_text.setToolTip("Tambah Teks Singkat")
            self.btn_add_paragraph.setToolTip("Tambah Paragraf")
        else:
            # Warna Mati (Disabled)
            disabled_style = "background-color: #504945; color: #a89984; font-weight: bold;"
            self.btn_add_content.setStyleSheet(disabled_style)
            self.btn_add_text.setStyleSheet(disabled_style)
            self.btn_add_paragraph.setStyleSheet(disabled_style)
            
            msg = "Pilih Frame terlebih dahulu"
            self.btn_add_content.setToolTip(msg)
            self.btn_add_text.setToolTip(msg)
            self.btn_add_paragraph.setToolTip(msg)
               
    def _connect_internal_signals(self):
        # self.btn_new.clicked.connect(self.action_add_new)
        self.btn_up.clicked.connect(self.action_move_up)
        self.btn_down.clicked.connect(self.action_move_down)
        self.btn_del.clicked.connect(self.action_delete)
        self.list_layers.itemClicked.connect(self._on_list_item_clicked)

    def set_delete_enabled(self, enabled):
        self.btn_del.setEnabled(enabled)
        if enabled:
            self.btn_del.setToolTip("Hapus Layer")
        else:
            self.btn_del.setToolTip("Layer Terkunci")
            
    def set_reorder_enabled(self, enabled):
        self.btn_up.setEnabled(enabled)
        self.btn_down.setEnabled(enabled)
        tooltip = "Pindah Layer" if enabled else "Layer Terkunci"
        self.btn_up.setToolTip(tooltip)
        self.btn_down.setToolTip(tooltip)

    # [MODIFIKASI] Menerima parameter shape
    def action_add_new(self, shape="portrait"):
        count = self.list_layers.count()
        if count < 26: frame_char = chr(65 + count)
        else: frame_char = f"Z{count}"
        name = f"FRAME {frame_char}"
        item = QListWidgetItem(name)
        self.list_layers.addItem(item)
        self.list_layers.setCurrentItem(item)
        
        # Emit (Nama, Bentuk)
        self.sig_layer_created.emit(frame_char, shape)

    def action_move_up(self):
        row = self.list_layers.currentRow()
        if row > 0:
            item = self.list_layers.takeItem(row)
            self.list_layers.insertItem(row - 1, item)
            self.list_layers.setCurrentRow(row - 1)
            self.sig_layer_reordered.emit(row, row - 1)

    def action_move_down(self):
        row = self.list_layers.currentRow()
        if row < self.list_layers.count() - 1:
            item = self.list_layers.takeItem(row)
            self.list_layers.insertItem(row + 1, item)
            self.list_layers.setCurrentRow(row + 1)
            self.sig_layer_reordered.emit(row, row + 1)
            
    def action_delete(self):
        row = self.list_layers.currentRow()
        if row >= 0:
            item = self.list_layers.takeItem(row)
            txt = item.text()
            if "FRAME " in txt:
                code = txt.replace("FRAME ", "")
                self.sig_delete_layer.emit(code)

    def _on_list_item_clicked(self, item):
        txt = item.text() 
        if "FRAME " in txt:
            code = txt.replace("FRAME ", "")
            self.sig_layer_selected.emit(code)

    def select_layer_by_code(self, code):
        target_name = f"FRAME {code}"
        for i in range(self.list_layers.count()):
            item = self.list_layers.item(i)
            if item.text() == target_name:
                self.list_layers.setCurrentItem(item)
                self.list_layers.scrollToItem(item)
                break

==========================================================================================
FILE: gui\left_panel\presetchroma_panel.py
==========================================================================================
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QGridLayout, QLabel, 
                             QPushButton, QScrollArea, QFrame, QHBoxLayout, QMessageBox)
from PySide6.QtCore import Qt

class PresetChromaPanel(QScrollArea):
    def __init__(self):
        super().__init__()
        self.setWidgetResizable(True)
        self.setStyleSheet("border: none;") 
        
        container = QWidget()
        self.main_layout = QVBoxLayout(container)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(15)
        
        # 1. Header (Tombol Import & Save)
        self._init_header()
        
        # 2. Grid Thumbnail (Library)
        self._init_grid()
        
        self.main_layout.addStretch()
        self.setWidget(container)

    def _init_header(self):
        """Header berisi tombol Import File Baru & Simpan Settingan Layer Aktif"""
        header_group = QWidget()
        header_layout = QVBoxLayout(header_group)
        header_layout.setContentsMargins(0, 0, 0, 0)
        header_layout.setSpacing(8)
        
        lbl_info = QLabel("CHROMA LIBRARY")
        lbl_info.setStyleSheet("color: #ebdbb2; font-weight: bold; font-size: 14px;")
        
        # Tombol Import File (Raw)
        self.btn_import = QPushButton(" + Import File")
        self.btn_import.setFixedHeight(35)
        self.btn_import.setStyleSheet("""
            QPushButton {
                background-color: #3a0ca3; color: white; font-weight: bold; border-radius: 4px;
            }
            QPushButton:hover { background-color: #4361ee; }
        """)
        self.btn_import.clicked.connect(lambda: print("Import File Clicked"))
        
        # Tombol Save Current Selection (Simpan settingan layer yg diedit)
        self.btn_save_selection = QPushButton(" üíæ Save Selected Layer as Preset")
        self.btn_save_selection.setFixedHeight(35)
        self.btn_save_selection.setStyleSheet("""
            QPushButton {
                background-color: #d65d0e; color: #fbf1c7; font-weight: bold; border-radius: 4px;
            }
            QPushButton:hover { background-color: #fe8019; color: #282828; }
        """)
        self.btn_save_selection.clicked.connect(self.on_save_clicked)
        
        header_layout.addWidget(lbl_info)
        
        # Baris Tombol
        btn_row = QHBoxLayout()
        btn_row.addWidget(self.btn_import)
        btn_row.addWidget(self.btn_save_selection)
        header_layout.addLayout(btn_row)
        
        self.main_layout.addWidget(header_group)

    def _init_grid(self):
        self.grid_container = QWidget()
        self.grid = QGridLayout(self.grid_container)
        self.grid.setSpacing(10)
        self.grid.setContentsMargins(0, 0, 0, 0)
        
        # Dummy Data Library
        self._add_card(0, "Fire Explosion", "#e74c3c")
        self._add_card(1, "Smoke Effect", "#95a5a6")
        self._add_card(2, "Dinosaur Run", "#2ecc71")
        self._add_card(3, "Meme Shia", "#f1c40f")
        self._add_card(4, "Rain Overlay", "#3498db")
        
        self.main_layout.addWidget(self.grid_container)

    def _add_card(self, index, name, color_code):
        card = QFrame()
        card.setFixedSize(135, 160) # Tinggi sedikit ditambah untuk tombol hapus
        card.setStyleSheet(f"""
            QFrame {{
                background-color: #3c3836; 
                border: 1px solid #504945; 
                border-radius: 8px;
            }}
            QFrame:hover {{
                border: 1px solid #fe8019;
            }}
        """)
        
        layout = QVBoxLayout(card)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(2)
        
        # 1. Thumbnail
        thumb = QLabel()
        thumb.setStyleSheet(f"background-color: {color_code}; border-radius: 4px;")
        thumb.setFixedSize(123, 75)
        thumb.setAlignment(Qt.AlignCenter)
        thumb.setText("GS")
        
        # 2. Nama Item
        lbl_name = QLabel(name)
        lbl_name.setStyleSheet("color: #ebdbb2; font-size: 11px; font-weight: bold; border: none; background: transparent;")
        lbl_name.setAlignment(Qt.AlignCenter)
        lbl_name.setFixedHeight(20)
        
        # 3. Container Tombol (Load & Delete)
        action_layout = QHBoxLayout()
        action_layout.setContentsMargins(0, 5, 0, 0)
        action_layout.setSpacing(4)
        
        # Tombol Load (Hijau/Standar)
        btn_load = QPushButton("Load")
        btn_load.setCursor(Qt.PointingHandCursor)
        btn_load.setFixedHeight(24)
        btn_load.setStyleSheet("""
            QPushButton {
                background-color: #504945; border: none; color: #fbf1c7; font-size: 10px; border-radius: 3px;
            }
            QPushButton:hover { background-color: #689d6a; color: white; }
        """)
        btn_load.clicked.connect(lambda: print(f"Loading Preset: {name}"))
        
        # Tombol Delete (Merah Kecil)
        btn_del = QPushButton("X")
        btn_del.setCursor(Qt.PointingHandCursor)
        btn_del.setFixedSize(24, 24)
        btn_del.setStyleSheet("""
            QPushButton {
                background-color: #282828; border: 1px solid #cc241d; color: #cc241d; font-weight: bold; border-radius: 3px;
            }
            QPushButton:hover { background-color: #cc241d; color: white; }
        """)
        # Simulasi Hapus
        btn_del.clicked.connect(lambda: self.on_delete_clicked(card, name))
        
        action_layout.addWidget(btn_load)
        action_layout.addWidget(btn_del)
        
        layout.addWidget(thumb)
        layout.addWidget(lbl_name)
        layout.addLayout(action_layout)
        
        # Posisi Grid
        row = index // 2
        col = index % 2
        self.grid.addWidget(card, row, col)

    def on_save_clicked(self):
        print("Menyimpan settingan Chroma layer terpilih ke library...")
        # Di sini nanti logika mengambil data dari MediaTab/Engine
        # Lalu self._add_card(...) baru

    def on_delete_clicked(self, card_widget, name):
        # Konfirmasi Hapus (Opsional)
        print(f"Menghapus preset: {name}")
        card_widget.deleteLater() # Menghapus widget kartu dari UI

==========================================================================================
FILE: gui\left_panel\render_tab.py
==========================================================================================
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QGroupBox, QHBoxLayout, 
                             QLabel, QComboBox, QLineEdit, QPushButton)

class RenderTab(QWidget):
    def __init__(self):
        super().__init__()
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0,0,0,0)
        
        group = QGroupBox("EKSPOR VIDEO")
        vbox = QVBoxLayout(group)
        
        # Quality
        self.combo_quality = QComboBox()
        self.combo_quality.addItems(["480p (Cepat)", "720p (HD)", "1080p (Full HD)", "4K (Ultra)"])
        vbox.addWidget(QLabel("Kualitas Render:"))
        vbox.addWidget(self.combo_quality)
        
        # Path
        hbox = QHBoxLayout()
        self.txt_path = QLineEdit()
        self.txt_path.setPlaceholderText("C:/Output/Video.mp4")
        self.btn_browse = QPushButton("...")
        self.btn_browse.setFixedWidth(40)
        hbox.addWidget(self.txt_path)
        hbox.addWidget(self.btn_browse)
        vbox.addLayout(hbox)
        
        # --- BAGIAN TOMBOL ACTION (MODIFIKASI DI SINI) ---
        
        # Buat layout horizontal agar tombol bersebelahan
        action_layout = QHBoxLayout()
        
        # 1. Tombol Mulai (Warna Hijau Teal)
        self.btn_render = QPushButton("üé¨ MULAI RENDER")
        self.btn_render.setFixedHeight(45)
        self.btn_render.setStyleSheet("background-color: #2a9d8f; color: white; font-size: 14px; font-weight: bold;")
        
        # 2. Tombol Stop (Warna Merah) - Tambahan Baru
        self.btn_stop = QPushButton("üõë STOP")
        self.btn_stop.setFixedHeight(45)
        self.btn_stop.setStyleSheet("background-color: #e63946; color: white; font-size: 14px; font-weight: bold;")
        self.btn_stop.setEnabled(False) # Default mati, nyala pas lagi render
        
        # Masukkan kedua tombol ke layout horizontal
        action_layout.addWidget(self.btn_render, stretch=3) # Lebih lebar dikit
        action_layout.addWidget(self.btn_stop, stretch=1)
        
        vbox.addStretch()
        vbox.addLayout(action_layout) # Masukkan layout tombol ke layout utama
        
        layout.addWidget(group)

==========================================================================================
FILE: gui\left_panel\template_tab.py
==========================================================================================
import os
import json
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QGridLayout, QLabel, 
                             QPushButton, QScrollArea, QFrame, QInputDialog, QMessageBox)
from PySide6.QtCore import Qt, Signal

# Folder penyimpanan
TEMPLATE_DIR = "saved_templates"

class TemplateTab(QScrollArea):
    # Sinyal saat user klik "Load" pada salah satu template
    sig_load_template = Signal(dict) 

    def __init__(self):
        super().__init__()
        self.setWidgetResizable(True)
        self.setStyleSheet("border: none;") 
        
        # Pastikan folder ada
        if not os.path.exists(TEMPLATE_DIR):
            os.makedirs(TEMPLATE_DIR)
            
        container = QWidget()
        self.main_layout = QVBoxLayout(container)
        
        # Header / Refresh Button
        header = QFrame()
        h_layout = QVBoxLayout(header)
        btn_refresh = QPushButton("üîÑ Refresh List")
        btn_refresh.clicked.connect(self.refresh_grid)
        h_layout.addWidget(btn_refresh)
        self.main_layout.addWidget(header)
        
        # Grid Container
        self.grid_container = QWidget()
        self.grid = QGridLayout(self.grid_container)
        self.grid.setSpacing(15)
        self.main_layout.addWidget(self.grid_container)
        
        self.main_layout.addStretch()
        self.setWidget(container)
        
        # Load awal
        self.refresh_grid()

    def refresh_grid(self):
        """ Membaca folder JSON dan membuat kartu grid """
        # Hapus widget lama
        for i in reversed(range(self.grid.count())): 
            self.grid.itemAt(i).widget().setParent(None)
            
        files = [f for f in os.listdir(TEMPLATE_DIR) if f.endswith(".json")]
        
        for idx, filename in enumerate(files):
            name = filename.replace(".json", "")
            self._add_template_card(idx, name, filename)

    def _add_template_card(self, index, name, filename):
        card = QFrame()
        card.setFixedSize(140, 170)
        card.setStyleSheet("""
            QFrame { background-color: #3c3836; border: 1px solid #504945; border-radius: 8px; }
            QFrame:hover { border: 1px solid #fe8019; }
        """)
        
        layout = QVBoxLayout(card)
        layout.setContentsMargins(5, 5, 5, 5)
        
        # 1. Preview (Placeholder Warna)
        thumb = QLabel("TEMPLATE")
        thumb.setStyleSheet("background-color: #458588; color: white; border-radius: 4px; font-weight: bold;")
        thumb.setFixedSize(128, 90)
        thumb.setAlignment(Qt.AlignCenter)
        
        # 2. Nama
        lbl_name = QLabel(name)
        lbl_name.setStyleSheet("color: #ebdbb2; font-weight: bold; border: none; background: transparent;")
        lbl_name.setAlignment(Qt.AlignCenter)
        
        # 3. Tombol Load
        btn_load = QPushButton("Load")
        btn_load.setCursor(Qt.PointingHandCursor)
        btn_load.setStyleSheet("background-color: #d65d0e; color: white; border: none; border-radius: 3px;")
        btn_load.clicked.connect(lambda: self.load_from_file(filename))

        # 4. Tombol Delete (Kecil)
        btn_del = QPushButton("Del")
        btn_del.setCursor(Qt.PointingHandCursor)
        btn_del.setStyleSheet("background-color: #282828; color: #cc241d; border: 1px solid #cc241d; border-radius: 3px;")
        btn_del.clicked.connect(lambda: self.delete_file(filename))
        
        layout.addWidget(thumb)
        layout.addWidget(lbl_name)
        layout.addWidget(btn_load)
        layout.addWidget(btn_del)
        
        row = index // 2
        col = index % 2
        self.grid.addWidget(card, row, col)

    def save_new_template(self, data_dict):
        """ Dipanggil oleh Main.py saat user klik Save di PreviewPanel """
        name, ok = QInputDialog.getText(self, "Save Template", "Masukkan Nama Template:")
        if ok and name:
            filepath = os.path.join(TEMPLATE_DIR, f"{name}.json")
            try:
                with open(filepath, 'w') as f:
                    json.dump(data_dict, f, indent=4)
                QMessageBox.information(self, "Success", f"Template '{name}' berhasil disimpan!")
                self.refresh_grid()
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Gagal menyimpan: {str(e)}")

    def load_from_file(self, filename):
        filepath = os.path.join(TEMPLATE_DIR, filename)
        try:
            with open(filepath, 'r') as f:
                data = json.load(f)
            self.sig_load_template.emit(data) # Kirim data ke Main -> Preview
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Gagal memuat: {str(e)}")

    def delete_file(self, filename):
        filepath = os.path.join(TEMPLATE_DIR, filename)
        confirm = QMessageBox.question(self, "Hapus", f"Hapus template '{filename}'?", QMessageBox.Yes | QMessageBox.No)
        if confirm == QMessageBox.Yes:
            os.remove(filepath)
            self.refresh_grid()

==========================================================================================
FILE: gui\left_panel\__init__.py
==========================================================================================


==========================================================================================
FILE: gui\right_panel\caption_tab.py
==========================================================================================
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QGroupBox, QGridLayout, 
                             QLabel, QSpinBox, QPushButton, QComboBox, 
                             QTextEdit, QScrollArea, QCheckBox, QHBoxLayout, 
                             QFontComboBox, QFrame, QLineEdit) # <--- Ditambah QLineEdit
from PySide6.QtCore import Qt

from PySide6.QtCore import Signal


class CaptionTab(QScrollArea):
    sig_generate_caption = Signal(dict) # Kirim opsi generate caption
    def __init__(self):
        super().__init__()
        self.setWidgetResizable(True)
        container = QWidget()
        self.layout = QVBoxLayout(container)
        self.layout.setSpacing(15)
        
        # 1. Panel Auto Caption
        self._init_generation()
        
        # 2. Toggle Aktivasi Dummy
        self._init_activation_toggle()
        
        # 3. Panel Gaya/Styling (SUDAH DITAMBAH STROKE COLOR)
        self._init_style()
        
        # 4. Dropdown Preset
        self._init_preset_section()
        
        # 5. Editor Manual
        self._init_editor()
        
        self.layout.addStretch()
        self.setWidget(container)

    def _init_generation(self):
        group = QGroupBox("AUTO CAPTION")
        grid = QGridLayout(group)
        
        # --- [BARU] AssemblyAI Key Input (Row 0) ---
        row_api = QHBoxLayout()
        row_api.setContentsMargins(0, 0, 0, 0)
        
        self.txt_api_key = QLineEdit()
        self.txt_api_key.setPlaceholderText("Paste AssemblyAI API Key...")
        self.txt_api_key.setEchoMode(QLineEdit.Password) # Password mode agar key tersembunyi
        self.txt_api_key.setStyleSheet("background-color: #1d2021; color: #ebdbb2; border: 1px solid #504945; border-radius: 4px;")
        
        self.btn_save_key = QPushButton("Save")
        self.btn_save_key.setFixedWidth(50)
        self.btn_save_key.setStyleSheet("background-color: #504945; color: #fbf1c7; border: none; border-radius: 4px; font-weight: bold;")
        
        row_api.addWidget(QLabel("AssemblyAI Key:"))
        row_api.addWidget(self.txt_api_key)
        row_api.addWidget(self.btn_save_key)
        
        # Masukkan baris API Key ke Grid paling atas (Row 0, Span 2 kolom)
        grid.addLayout(row_api, 0, 0, 1, 2)

        # --- [LAMA] Bahasa (Digeser ke Row 1) ---
        self.combo_lang = QComboBox()
        self.combo_lang.addItems(["Indonesia", "English",])
        
        grid.addWidget(QLabel("Bahasa:"), 1, 0)
        grid.addWidget(self.combo_lang, 1, 1)
        
        # --- [LAMA] Tombol Generate (Digeser ke Row 2) ---
        self.btn_generate = QPushButton("‚ö° Generate Auto Caption")
        self.btn_generate.setStyleSheet("background-color: #d65d0e; color: #fbf1c7; border: none; font-weight: bold;")
        self.btn_generate.setFixedHeight(35)
        
        self.btn_generate.clicked.connect(self._emit_generate)

        
        grid.addWidget(self.btn_generate, 2, 0, 1, 2)
        
        self.layout.addWidget(group)
    def _emit_generate(self):
        data = {
            "language": self.combo_lang.currentText(),
            "preset": self.combo_preset.currentText(),
            "active": self.chk_active.isChecked(),
            "api_key": self.txt_api_key.text().strip()
        }
        self.sig_generate_caption.emit(data)

    def _init_activation_toggle(self):
        container = QFrame()
        container.setStyleSheet("""
            QFrame {
                background-color: #3c3836; 
                border: 1px solid #504945; 
                border-radius: 6px;
            }
        """)
        layout = QHBoxLayout(container)
        layout.setContentsMargins(10, 8, 10, 8)
        
        self.chk_active = QCheckBox("Aktifkan Preview Dummy Caption")
        self.chk_active.setToolTip("Jika ON: Menampilkan contoh caption dan akan dirender otomatis.")
        self.chk_active.setStyleSheet("font-weight: bold; color: #fe8019; font-size: 13px; border: none;")
        
        layout.addWidget(self.chk_active)
        self.layout.addWidget(container)

    def _init_style(self):
        group = QGroupBox("GAYA CAPTION")
        grid = QGridLayout(group)
        grid.setVerticalSpacing(10)
        
        # Font & Ukuran
        self.font_combo = QFontComboBox()
        
        self.spn_size = QSpinBox()
        self.spn_size.setRange(10, 200)
        self.spn_size.setValue(24)
        self.spn_size.setSuffix(" px")
        
        # Tombol Warna Dasar
        self.btn_text_color = QPushButton("Warna Teks")
        self.btn_bg_color = QPushButton("Warna Background")
        
        # --- STROKE SECTION (BARU) ---
        self.chk_stroke = QCheckBox("Stroke")
        
        self.spn_stroke_width = QSpinBox()
        self.spn_stroke_width.setRange(0, 20)
        self.spn_stroke_width.setPrefix("Tebal: ")
        
        self.btn_stroke_color = QPushButton("Warna Stroke")
        
        # Layouting Grid
        # Baris 0: Font
        grid.addWidget(QLabel("Font:"), 0, 0)
        grid.addWidget(self.font_combo, 0, 1)
        
        # Baris 1: Ukuran
        grid.addWidget(QLabel("Ukuran:"), 1, 0)
        grid.addWidget(self.spn_size, 1, 1)
        
        # Baris 2: Warna Teks & BG
        row_color = QHBoxLayout()
        row_color.addWidget(self.btn_text_color)
        row_color.addWidget(self.btn_bg_color)
        grid.addLayout(row_color, 2, 0, 1, 2)
        
        # Baris 3: Konfigurasi Stroke Lengkap
        row_stroke = QHBoxLayout()
        row_stroke.addWidget(self.chk_stroke)
        row_stroke.addWidget(self.spn_stroke_width)
        row_stroke.addWidget(self.btn_stroke_color)
        grid.addLayout(row_stroke, 3, 0, 1, 2)
        
        self.layout.addWidget(group)

    def _init_preset_section(self):
        container = QWidget()
        layout = QHBoxLayout(container)
        layout.setContentsMargins(0, 5, 0, 0)
        
        layout.addWidget(QLabel("Pilih Preset Style:"))
        
        self.combo_preset = QComboBox()
        self.combo_preset.addItems([
            "Custom (Manual)", 
            "Karaoke Highlight (Word-by-word)", 
            "Netflix Standard", 
            "Youtube Shorts (Yellow Bold)", 
            "Cinematic Minimal"
        ])
        
        layout.addWidget(self.combo_preset)
        self.layout.addWidget(container)

    def _init_editor(self):
        group = QGroupBox("EDITOR SUBTITLE")
        layout = QVBoxLayout(group)
        
        self.txt_editor = QTextEdit()
        self.txt_editor.setPlaceholderText("00:00 - Halo semuanya...\n00:05 - Selamat datang di Mamen Pro...")
        self.txt_editor.setMinimumHeight(150)
        self.txt_editor.setStyleSheet("background-color: #1d2021; border: 1px solid #504945; font-family: Consolas; color: #ebdbb2;")
        
        layout.addWidget(self.txt_editor)
        
        btn_layout = QGridLayout()
        self.btn_import = QPushButton("Import .SRT")
        self.btn_export = QPushButton("Export .SRT")
        
        btn_layout.addWidget(self.btn_import, 0, 0)
        btn_layout.addWidget(self.btn_export, 0, 1)
        
        layout.addLayout(btn_layout)
        self.layout.addWidget(group)
        
# ... (kode class PreviewPanel di atas) ...

if __name__ == "__main__":
    import sys
    from PySide6.QtWidgets import QApplication

    app = QApplication(sys.argv)
    
    # --- SIMULASI UKURAN ---
    MAIN_WINDOW_W = 1920  # Anggap layar Full HD
    MAIN_WINDOW_H = 1000  # Tinggi layar dikurangi taskbar
    
    # Hitung jatah panel tengah (3/5 dari lebar total)
    my_width = int(MAIN_WINDOW_W * (1/6))
    my_height = MAIN_WINDOW_H * (3/5)

    window = QWidget()
    layout = QVBoxLayout(window)
    layout.setContentsMargins(0,0,0,0) # Hilangkan margin biar akurat
    
    panel = CaptionTab()
    layout.addWidget(panel)
    
    # Terapkan hasil hitungan
    window.resize(my_width, my_height)
    
    window.setWindowTitle(f"Testing Preview Panel ({my_width}x{my_height})")
    window.show()
    
    sys.exit(app.exec())

==========================================================================================
FILE: gui\right_panel\media_tab.py
==========================================================================================
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QGroupBox, QGridLayout, 
                             QLabel, QSpinBox, QPushButton, QSlider, QScrollArea, QCheckBox)
from PySide6.QtCore import Qt

class MediaTab(QScrollArea):
    def __init__(self):
        super().__init__()
        self.setWidgetResizable(True)
        container = QWidget()
        self.layout = QVBoxLayout(container)
        
        self._init_transform()
        self._init_visual()
        self._init_chroma()
        self._init_frame_setting() # <-- Grup baru ditambahkan di sini
        
        self.layout.addStretch()
        self.setWidget(container)

    def _init_transform(self):
        group = QGroupBox("TRANSFORM & POSISI")
        grid = QGridLayout(group)
        
        self.spn_x = QSpinBox(); self.spn_x.setRange(-5000, 5000); self.spn_x.setPrefix("X: ")
        self.spn_y = QSpinBox(); self.spn_y.setRange(-5000, 5000); self.spn_y.setPrefix("Y: ")
        self.spn_scale = QSpinBox(); self.spn_scale.setRange(1, 1000); self.spn_scale.setValue(100); self.spn_scale.setSuffix("%")
        self.spn_rot = QSpinBox(); self.spn_rot.setRange(-360, 360); self.spn_rot.setSuffix("¬∞")
        self.spn_opacity = QSpinBox(); self.spn_opacity.setRange(0, 100); self.spn_opacity.setValue(100); self.spn_opacity.setSuffix("%")

        # --- Tambahan Input SF-L & SF-R ---
        self.spn_sf_l = QSpinBox(); self.spn_sf_l.setRange(-1000, 1000); self.spn_sf_l.setPrefix("SF-L: ")
        self.spn_sf_r = QSpinBox(); self.spn_sf_r.setRange(-1000, 1000); self.spn_sf_r.setPrefix("SF-R: ")

        grid.addWidget(self.spn_x, 0, 0); grid.addWidget(self.spn_y, 0, 1)
        grid.addWidget(self.spn_scale, 1, 0); grid.addWidget(self.spn_rot, 1, 1)
        grid.addWidget(QLabel("Opacity:"), 2, 0); grid.addWidget(self.spn_opacity, 2, 1)
        
        # Menambahkan SF di baris ke-3
        grid.addWidget(self.spn_sf_l, 3, 0)
        grid.addWidget(self.spn_sf_r, 3, 1)
        
        self.layout.addWidget(group)

    def _init_visual(self):
        group = QGroupBox("COLOR CORRECTION")
        grid = QGridLayout(group)
        
        self.spn_bright = QSpinBox(); self.spn_bright.setRange(-100, 100)
        self.spn_contrast = QSpinBox(); self.spn_contrast.setRange(-100, 100)
        self.spn_sat = QSpinBox(); self.spn_sat.setRange(-100, 100)
        self.spn_hue = QSpinBox(); self.spn_hue.setRange(-180, 180)
        
        grid.addWidget(QLabel("Brightness"), 0, 0); grid.addWidget(self.spn_bright, 0, 1)
        grid.addWidget(QLabel("Contrast"), 1, 0); grid.addWidget(self.spn_contrast, 1, 1)
        grid.addWidget(QLabel("Saturation"), 2, 0); grid.addWidget(self.spn_sat, 2, 1)
        grid.addWidget(QLabel("Hue"), 3, 0); grid.addWidget(self.spn_hue, 3, 1)
        
        self.layout.addWidget(group)

    def _init_chroma(self):
        group = QGroupBox("CHROMA KEY (GREEN SCREEN)")
        grid = QGridLayout(group)
        
        # Komponen lama
        self.btn_pick = QPushButton("Pick Color")
        self.spn_sim = QSpinBox(); self.spn_sim.setPrefix("Sim: ")
        self.spn_smooth = QSpinBox(); self.spn_smooth.setPrefix("Smooth: ")
        
        # Tambahan Slider RGB
        self.lbl_r = QLabel("R")
        self.slider_r = QSlider(Qt.Horizontal); self.slider_r.setRange(0, 255)
        self.spn_r = QSpinBox(); self.spn_r.setRange(0, 255)
        
        self.lbl_g = QLabel("G")
        self.slider_g = QSlider(Qt.Horizontal); self.slider_g.setRange(0, 255)
        self.spn_g = QSpinBox(); self.spn_g.setRange(0, 255)

        self.lbl_b = QLabel("B")
        self.slider_b = QSlider(Qt.Horizontal); self.slider_b.setRange(0, 255)
        self.spn_b = QSpinBox(); self.spn_b.setRange(0, 255)

        # Menyusun Layout (Grid 3 kolom)
        grid.addWidget(self.btn_pick, 0, 0, 1, 3)
        grid.addWidget(self.spn_sim, 1, 0, 1, 2)
        grid.addWidget(self.spn_smooth, 1, 2)
        
        grid.addWidget(self.lbl_r, 2, 0); grid.addWidget(self.slider_r, 2, 1); grid.addWidget(self.spn_r, 2, 2)
        grid.addWidget(self.lbl_g, 3, 0); grid.addWidget(self.slider_g, 3, 1); grid.addWidget(self.spn_g, 3, 2)
        grid.addWidget(self.lbl_b, 4, 0); grid.addWidget(self.slider_b, 4, 1); grid.addWidget(self.spn_b, 4, 2)
        
        self.layout.addWidget(group)

        # Connect Slider <-> SpinBox
        self.slider_r.valueChanged.connect(self.spn_r.setValue)
        self.spn_r.valueChanged.connect(self.slider_r.setValue)
        self.slider_g.valueChanged.connect(self.spn_g.setValue)
        self.spn_g.valueChanged.connect(self.slider_g.setValue)
        self.slider_b.valueChanged.connect(self.spn_b.setValue)
        self.spn_b.valueChanged.connect(self.slider_b.setValue)

    def _init_frame_setting(self):
        """Grup baru untuk setting Frame Size, Rotation dan Lock"""
        group = QGroupBox("FRAME SETTING")
        grid = QGridLayout(group)
        
        # Size (Width & Height)
        self.spn_frame_w = QSpinBox(); self.spn_frame_w.setRange(1, 10000); self.spn_frame_w.setPrefix("W: ")
        self.spn_frame_h = QSpinBox(); self.spn_frame_h.setRange(1, 10000); self.spn_frame_h.setPrefix("H: ")
        
        # Rotation
        self.spn_frame_rot = QSpinBox(); self.spn_frame_rot.setRange(-360, 360); self.spn_frame_rot.setPrefix("Rot: "); self.spn_frame_rot.setSuffix("¬∞")
        
        # Toggle Lock Frame
        self.chk_lock_frame = QCheckBox("Lock Frame")
        
        # Layouting
        grid.addWidget(self.spn_frame_w, 0, 0)
        grid.addWidget(self.spn_frame_h, 0, 1)
        grid.addWidget(self.spn_frame_rot, 1, 0)
        grid.addWidget(self.chk_lock_frame, 1, 1)
        
        self.layout.addWidget(group)
        
# ... (kode class PreviewPanel di atas) ...

# TAMBAHAN DI BAWAH FILE:
if __name__ == "__main__":
    import sys
    from PySide6.QtWidgets import QApplication

    app = QApplication(sys.argv)
    
    # Bungkus panel kamu dalam window dummy
    window = QWidget() # Atau QMainWindow
    layout = QVBoxLayout(window)
    
    # PANGGIL PANEL YANG LAGI DIEDIT
    panel = MediaTab() 
    layout.addWidget(panel)
    
    window.resize(800, 600) # Ukuran sementara
    window.show()
    
    # Bisa tambahkan data palsu (mock data) buat ngetes
    # panel.set_status("Mode Testing...") 
    
    sys.exit(app.exec())

==========================================================================================
FILE: gui\right_panel\setting_panel.py
==========================================================================================
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QTabWidget)
from PySide6.QtCore import Qt, Signal

# Import Modul
from gui.right_panel.media_tab import MediaTab
from gui.right_panel.text_tab import TextTab
from gui.right_panel.caption_tab import CaptionTab

class SettingPanel(QWidget):
    on_setting_change = Signal(dict) 

    def __init__(self):
        super().__init__()
        self.setFixedWidth(340)
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(0, 0, 0, 0)
        
        self.tabs = QTabWidget()
        self.media_tab = MediaTab()
        self.text_tab = TextTab()
        self.caption_tab = CaptionTab()
        
        self.tabs.addTab(self.media_tab, "Media")
        self.tabs.addTab(self.text_tab, "Teks")
        self.tabs.addTab(self.caption_tab, "Caption")
        
        self.main_layout.addWidget(self.tabs)

        self._connect_signals()

    def _connect_signals(self):
        # 1. Konten (Clip) - Mempengaruhi ISI Frame
        self.media_tab.spn_x.valueChanged.connect(self._emit_change)
        self.media_tab.spn_y.valueChanged.connect(self._emit_change)
        self.media_tab.spn_scale.valueChanged.connect(self._emit_change)
        self.media_tab.spn_rot.valueChanged.connect(self._emit_change)
        self.media_tab.spn_opacity.valueChanged.connect(self._emit_change)
        
        # Smart Frame (Crop)
        self.media_tab.spn_sf_l.valueChanged.connect(self._emit_change)
        self.media_tab.spn_sf_r.valueChanged.connect(self._emit_change)

        # 2. Frame (Wadah) - Mempengaruhi BENTUK Frame
        self.media_tab.spn_frame_w.valueChanged.connect(self._emit_change)
        self.media_tab.spn_frame_h.valueChanged.connect(self._emit_change)
        self.media_tab.spn_frame_rot.valueChanged.connect(self._emit_change)
        
        # Lock
        self.media_tab.chk_lock_frame.toggled.connect(self._emit_change)

    def _emit_change(self):
        """Mengambil semua nilai dari UI dan mengirimnya sebagai signal"""
        data = {
            "x": self.media_tab.spn_x.value(),
            "y": self.media_tab.spn_y.value(),
            "scale": self.media_tab.spn_scale.value(),
            "rotation": self.media_tab.spn_rot.value(), # Rotasi Clip
            "opacity": self.media_tab.spn_opacity.value(),
            "sf_l": self.media_tab.spn_sf_l.value(),
            "sf_r": self.media_tab.spn_sf_r.value(),
            
            "frame_w": self.media_tab.spn_frame_w.value(),
            "frame_h": self.media_tab.spn_frame_h.value(),
            "frame_rot": self.media_tab.spn_frame_rot.value(), # Rotasi Frame
            "lock": self.media_tab.chk_lock_frame.isChecked()
        }
        # Block signal agar tidak loop (optional safety)
        self.on_setting_change.emit(data)

    def set_values(self, data):
        """Menerima data dari Main Window (saat seleksi berubah) dan update UI"""
        self.blockSignals(True)
        
        # Block signals UI elements (agar tidak memicu update loop saat set nilai)
        self.media_tab.spn_x.blockSignals(True)
        self.media_tab.spn_y.blockSignals(True)
        self.media_tab.spn_scale.blockSignals(True)
        self.media_tab.spn_rot.blockSignals(True)
        self.media_tab.spn_opacity.blockSignals(True)
        self.media_tab.spn_sf_l.blockSignals(True)
        self.media_tab.spn_sf_r.blockSignals(True)
        
        self.media_tab.spn_frame_w.blockSignals(True)
        self.media_tab.spn_frame_h.blockSignals(True)
        self.media_tab.spn_frame_rot.blockSignals(True)
        self.media_tab.chk_lock_frame.blockSignals(True)

        # --- [UPDATE BAGIAN INI: LEBIH AMAN & RAPI] ---
        # Gunakan .get() untuk semua field.
        # Jika data hilang, dia akan pakai nilai default (0 atau 100) dan TIDAK AKAN ERROR.
        
        self.media_tab.spn_x.setValue(int(data.get("x", 0)))
        self.media_tab.spn_y.setValue(int(data.get("y", 0)))
        self.media_tab.spn_scale.setValue(int(data.get("scale", 100)))
        self.media_tab.spn_rot.setValue(int(data.get("rot", 0)))
        self.media_tab.spn_opacity.setValue(int(data.get("opacity", 100)))
        self.media_tab.spn_sf_l.setValue(int(data.get("sf_l", 0)))
        self.media_tab.spn_sf_r.setValue(int(data.get("sf_r", 0)))
        
        # Frame Properies
        self.media_tab.spn_frame_w.setValue(int(data.get("frame_w", 540)))
        self.media_tab.spn_frame_h.setValue(int(data.get("frame_h", 960)))
        self.media_tab.spn_frame_rot.setValue(int(data.get("frame_rot", 0)))
        
        # Handle Lock State
        is_locked = bool(data.get("lock", False))
        self.media_tab.chk_lock_frame.setChecked(is_locked)
        self._update_lock_state(is_locked)

        # Unblock signals
        self.media_tab.spn_x.blockSignals(False)
        self.media_tab.spn_y.blockSignals(False)
        self.media_tab.spn_scale.blockSignals(False)
        self.media_tab.spn_rot.blockSignals(False)
        self.media_tab.spn_opacity.blockSignals(False)
        self.media_tab.spn_sf_l.blockSignals(False)
        self.media_tab.spn_sf_r.blockSignals(False)
        
        self.media_tab.spn_frame_w.blockSignals(False)
        self.media_tab.spn_frame_h.blockSignals(False)
        self.media_tab.spn_frame_rot.blockSignals(False)
        self.media_tab.chk_lock_frame.blockSignals(False)
        
        self.blockSignals(False)

    def _update_lock_state(self, is_locked):
        """Mematikan input jika terkunci"""
        enabled = not is_locked
        self.media_tab.spn_x.setEnabled(enabled)
        self.media_tab.spn_y.setEnabled(enabled)
        self.media_tab.spn_frame_w.setEnabled(enabled)
        self.media_tab.spn_frame_h.setEnabled(enabled)
        self.media_tab.spn_frame_rot.setEnabled(enabled)
        
        # Scale/Rotasi konten mungkin masih bisa diedit meski frame terkunci (Opsional)
        # self.media_tab.spn_scale.setEnabled(enabled)
        # self.media_tab.spn_rot.setEnabled(enabled)

    # [METHOD BARU DITAMBAHKAN DISINI]
    def set_active_tab_by_type(self, content_type):
        """Berpindah tab otomatis berdasarkan tipe konten frame"""
        if content_type == "text":
            self.tabs.setCurrentIndex(1) # Pindah ke Tab Teks
        elif content_type == "media":
            self.tabs.setCurrentIndex(0) # Pindah ke Tab Media
        # Anda bisa menambahkan kondisi lain jika ada tab lain (misal caption)

==========================================================================================
FILE: gui\right_panel\text_tab.py
==========================================================================================
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QGroupBox, QGridLayout, 
                             QLabel, QSpinBox, QPushButton, QComboBox, 
                             QTextEdit, QScrollArea, QCheckBox, QHBoxLayout, 
                             QFontComboBox, QLineEdit, QButtonGroup)
from PySide6.QtCore import Qt

class TextTab(QScrollArea):
    def __init__(self):
        super().__init__()
        self.setWidgetResizable(True)
        container = QWidget()
        self.layout = QVBoxLayout(container)
        self.layout.setSpacing(15)
        
        # --- 1. PANEL ATAS: GAYA TEKS ---
        self._init_text_style()
        
        # --- 2. PANEL BAWAH: PARAGRAF ---
        self._init_paragraph_style()
        
        self.layout.addStretch()
        self.setWidget(container)

    def _init_text_style(self):
        group = QGroupBox("GAYA TEKS")
        layout = QVBoxLayout(group)
        layout.setSpacing(10) # Jarak antar baris
        
        # 1. Baris Pertama: Input Teks (Full Lebar)
        self.txt_content = QLineEdit("Mamen Pro Editor")
        self.txt_content.setPlaceholderText("Ketik Teks Utama di sini...")
        layout.addWidget(QLabel("Konten Teks:"))
        layout.addWidget(self.txt_content)
        
        # 2. Baris Kedua: Opsi Font (Full Lebar)
        self.font_combo = QFontComboBox()
        layout.addWidget(QLabel("Jenis Font:"))
        layout.addWidget(self.font_combo)
        
        # 3. Baris Ketiga: Ukuran + Tombol Warna
        row_size_color = QHBoxLayout()
        
        # Ukuran
        self.spn_size = QSpinBox()
        self.spn_size.setRange(8, 500)
        self.spn_size.setValue(60)
        self.spn_size.setSuffix(" px")
        self.spn_size.setPrefix("Size: ")
        
        # Tombol Warna
        self.btn_text_color = QPushButton(" Warna Teks")
        self.btn_text_color.setStyleSheet("text-align: left; padding-left: 10px; border-left: 5px solid #ffffff;")
        
        row_size_color.addWidget(self.spn_size)
        row_size_color.addWidget(self.btn_text_color)
        layout.addLayout(row_size_color)
        
        # 4. Baris Keempat: Stroke + Tebal + Warna
        row_stroke = QHBoxLayout()
        self.chk_stroke = QCheckBox("Stroke")
        
        self.spn_stroke_width = QSpinBox()
        self.spn_stroke_width.setRange(0, 50)
        self.spn_stroke_width.setPrefix("Tebal: ")
        
        self.btn_stroke_color = QPushButton("Warna")
        self.btn_stroke_color.setFixedWidth(60)
        self.btn_stroke_color.setStyleSheet("background-color: #000; color: #fff;") # Dummy color preview
        
        row_stroke.addWidget(self.chk_stroke)
        row_stroke.addWidget(self.spn_stroke_width)
        row_stroke.addWidget(self.btn_stroke_color)
        layout.addLayout(row_stroke)
        
        # 5. Baris Kelima: Background + Warna
        row_bg = QHBoxLayout()
        self.chk_bg = QCheckBox("Background")
        
        self.btn_bg_color = QPushButton("Warna Bg")
        
        row_bg.addWidget(self.chk_bg)
        row_bg.addWidget(self.btn_bg_color)
        layout.addLayout(row_bg)
        
        # 6. Baris Keenam: Shadow + Warna
        row_shadow = QHBoxLayout()
        self.chk_shadow = QCheckBox("Shadow")
        
        self.btn_shadow_color = QPushButton("Warna Shadow")
        
        row_shadow.addWidget(self.chk_shadow)
        row_shadow.addWidget(self.btn_shadow_color)
        layout.addLayout(row_shadow)
        
        self.layout.addWidget(group)

    def _init_paragraph_style(self):
        group = QGroupBox("PARAGRAF")
        layout = QVBoxLayout(group)
        layout.setSpacing(10)
        
        # 1. Baris Pertama: Kotak Input Paragraf
        self.txt_area = QTextEdit()
        self.txt_area.setPlaceholderText("Ketik paragraf panjang di sini...")
        self.txt_area.setMaximumHeight(80)
        layout.addWidget(self.txt_area)
        
        # 2. Baris Kedua: Align Icons + Spacing
        row_align = QHBoxLayout()
        
        # Tombol Align (Pake Unicode Icon biar simpel)
        self.btn_align_left = QPushButton("‚¨Ö")
        self.btn_align_center = QPushButton("‚Üî")
        self.btn_align_right = QPushButton("‚û°")
        self.btn_align_justify = QPushButton("‚â£")
        
        # Set tombol agar bisa di-check (toggle)
        for btn in [self.btn_align_left, self.btn_align_center, self.btn_align_right, self.btn_align_justify]:
            btn.setCheckable(True)
            btn.setFixedWidth(30)
            
        # Grouping agar hanya satu yang aktif
        self.align_group = QButtonGroup(self)
        self.align_group.addButton(self.btn_align_left)
        self.align_group.addButton(self.btn_align_center)
        self.align_group.addButton(self.btn_align_right)
        self.align_group.addButton(self.btn_align_justify)
        self.btn_align_left.setChecked(True) # Default Left
        
        # Spacing
        self.spn_line_height = QSpinBox()
        self.spn_line_height.setRange(0, 200)
        self.spn_line_height.setValue(100)
        self.spn_line_height.setPrefix("Spasi: ")
        
        row_align.addWidget(self.btn_align_left)
        row_align.addWidget(self.btn_align_center)
        row_align.addWidget(self.btn_align_right)
        row_align.addWidget(self.btn_align_justify)
        row_align.addWidget(self.spn_line_height)
        layout.addLayout(row_align)
        
        # 3. Baris Ketiga: Warna Background Paragraf
        self.btn_para_bg = QPushButton("Warna Background Paragraf")
        layout.addWidget(self.btn_para_bg)
        
        self.layout.addWidget(group)

==========================================================================================
FILE: gui\right_panel\__init__.py
==========================================================================================


==========================================================================================
FILE: gui\utils\bg_service.py
==========================================================================================
from PySide6.QtGui import QPixmap

class BackgroundService:
    @staticmethod
    def calculate_bg_geometry(pixmap: QPixmap, canvas_rect):
        """Menghitung scale dan posisi background (Logic Aspect Ratio)"""
        if not pixmap:
            return None
            
        bg_w = pixmap.width()
        bg_h = pixmap.height()
        canvas_w = canvas_rect.width()
        canvas_h = canvas_rect.height()
        
        final_scale = 100
        pos_x = 0
        pos_y = 0
        is_bg_portrait = bg_h > bg_w
        
        if is_bg_portrait:
            scale_w = canvas_w / bg_w
            scale_h = canvas_h / bg_h
            final_scale = max(scale_w, scale_h) * 100
            new_w = bg_w * (final_scale / 100)
            new_h = bg_h * (final_scale / 100)
            pos_x = (canvas_w - new_w) / 2
            pos_y = (canvas_h - new_h) / 2
        else:
            scale_h = canvas_h / bg_h
            final_scale = scale_h * 100
            new_w = bg_w * (final_scale / 100)
            pos_x = (canvas_w - new_w) / 2
            pos_y = 0

        return {
            'scale': int(final_scale),
            'x': int(pos_x),
            'y': int(pos_y)
        }

==========================================================================================
FILE: gui\utils\__init__.py
==========================================================================================


==========================================================================================
TOTAL FILES BUNDLED: 59
==========================================================================================
